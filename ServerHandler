local RS 			= game.ReplicatedStorage
local Game_Workspace = workspace:WaitForChild("Game_WorkSpace")
local Engine 		= RS:WaitForChild("Engine")
local Evt 			= Engine:WaitForChild("Events")
local Mods 			= Engine:WaitForChild("Modules")
local ArmModel 		= Engine:WaitForChild("ArmModel")
local GunModels 	= Engine:WaitForChild("GunModels")
local SVGunModels 	= Engine:WaitForChild("GrenadeModels")
local HUDs 			= Engine:WaitForChild("HUD")
local AttModels 	= Engine:WaitForChild("AttModels")
local AttModules  	= Engine:WaitForChild("AttModules")
local Rules			= Engine:WaitForChild("GameRules")

local gameRules		= require(Rules:WaitForChild("Config"))
local CombatLog		= require(Rules:WaitForChild("CombatLog"))
local SpringMod 	= require(Mods:WaitForChild("Spring"))
local HitMod 		= require(Mods:WaitForChild("Hitmarker"))
local Ultil			= require(Mods:WaitForChild("Utilities"))
local Ragdoll		= require(Mods:WaitForChild("Ragdoll"))
local Fracture		= require(Mods:WaitForChild("PartFractureModule"))
local BrickFracture		= require(Mods:WaitForChild("BrickFractureModule"))
local DestroySupports		= require(Mods:WaitForChild("DestroySupports"))
local Shrapnel		= require(Mods:WaitForChild("DirCast"))

local HttpService 	= game:GetService("HttpService")
local PhysicsService= game:GetService("PhysicsService")
local TS 			= game:GetService('TweenService')
local Debris 		= game:GetService("Debris")
local PhysicsService= game:GetService("PhysicsService")
local Run 			= game:GetService("RunService")

local plr 			= game.Players
local ACS_0 		= HttpService:GenerateGUID(true)
local Backup 		= 0

local PhysService = game:GetService("PhysicsService")
PhysService:RegisterCollisionGroup("Casings")
PhysService:RegisterCollisionGroup("Guns")
PhysService:CollisionGroupSetCollidable("Casings","Characters",false)
PhysService:CollisionGroupSetCollidable("Casings","Casings",false)
PhysService:CollisionGroupSetCollidable("Casings","Bullet",false)
PhysService:CollisionGroupSetCollidable("Guns","Characters",false)
PhysService:CollisionGroupSetCollidable("Guns","Guns",gameRules.WeaponCollisions)

_G.TempBannedPlayers = {} --Local ban list

local luaw,llaw,lhw, ruaw,rlaw,RA,LA,RightS,LeftS
local AnimBase,AnimBaseW

local dParts = {} -- Glass/Light storage
dParts.Glass = {}
dParts.Lights = {}

local gBreakParam = OverlapParams.new()

local AttTable = {
	AmmoAtt = nil,
	BarrelAtt = nil,
	MagAtt = nil,
	MuzzleAtt = nil,
	StockAtt = nil,
	OtherAtt = nil,
	SightAtt = nil,
	UnderBarrelAtt = nil,
}

-- Add new remote event at the top
local BleedOutFasterEvent = Evt:FindFirstChild("BleedOutFaster") or Instance.new("RemoteEvent", Evt)
BleedOutFasterEvent.Name = "BleedOutFaster"

local Explosion = {"287390459"; "287390954"; "287391087"; "287391197"; "287391361"; "287391499"; "287391567";}
-----------------------------------------------------------------

game.StarterPlayer.CharacterWalkSpeed = gameRules.NormalWalkSpeed

local function AccessID(SKP_0,SKP_1)
	if SKP_0.UserId == SKP_1 then
		return ACS_0
	else
		SKP_0:kick("Exploit Protocol")
		warn(SKP_0.Name.." - Potential Exploiter! Case 0-A: Client Tried To Access Server Code")
		table.insert(_G.TempBannedPlayers, SKP_0)
	end
end

Evt.AcessId.OnServerInvoke = AccessID


Evt.LandingGear.OnServerEvent:Connect(function(plr,Parts,GearStatus)
	print("Gear Reached server")
	Evt.LandingGear:FireAllClients(plr, Parts, GearStatus)
end)


Evt.SpawnAsJet.OnServerEvent:Connect(function(Player,JetName)
	local Jet = workspace.Vehicles.Planes["F-16"]:Clone()
	Jet.Parent = workspace.Vehicles.Planes
	Jet:SetPrimaryPartCFrame(workspace.JetSpawn.CFrame)

	local Seat = Jet.MainParts.Seat
	local PlaneTool = Seat.Plane
	local Prox = Seat.DrivePrompt

	local Crashed = Jet.Crashed
	local Origin = Jet.Origin

	wait(0.01)
	local char = Player.Character
	Seat:Sit(char.Humanoid)
	Prox.Enabled = false

end)

--Glenn's Anti-Exploit System (GAE for short). This code is very ugly, but does job done
local function compareTables(arr1, arr2)
	if	arr1.gunName==arr2.gunName 				and 
		arr1.Type==arr2.Type 					and
		arr1.ShootRate==arr2.ShootRate 			and
		arr1.Bullets==arr2.Bullets				and
		arr1.Impact==arr2.Impact                and
		arr1.CritMultiply==arr2.CritMultiply    
	then
		return true
	else
		return false
	end
end

local function secureSettings(Player,Gun,Module)

	if Gun and Gun:FindFirstChild("Settings") then
		local NewModule = require(Gun:FindFirstChild("Settings"))
		if (compareTables(Module, NewModule) == false) then
			Player:kick("Exploit Protocol")
			warn(Player.Name.." - Potential Exploiter! Case 4: Exploiting Gun Stats")	
			table.insert(_G.TempBannedPlayers, Player)
			return true
		else
			return true
		end
	else
		Player:kick("Exploit Protocol")
		warn(Player.Name.." - Potential Exploiter! Case 2: Missing Gun And Module")	
		return false
	end
end

function CheckForAtt(Model,Cat,Att)
	if Model.Nodes:FindFirstChild(Cat) then
		return true
	elseif Model:FindFirstChild(Cat) and Model:FindFirstChild(Cat):FindFirstChild(Att) then
		return true
	else
		return false
	end
end

function GiveXp(Player,Type,GunName,Settings)
	
	local Xp = 0
	if Type == "Head" then
		Xp = 175
	else
		Xp = 135
	end
	if Player.PlayerData.Level.Xp.Value + Xp > 1000 + (100*Player.PlayerData.Level.Value) then
		Player.PlayerData.Level.Value = Player.PlayerData.Level.Value + 1
		Player.PlayerData.Level.Xp.Value = Player.PlayerData.Level.Xp.Value + Xp - 1000 - (100*Player.PlayerData.Level.Value)
		Evt.RankUp:FireClient(Player,"Rank",nil,Player.PlayerData.Level.Value)
		
		for i,v in pairs(RS.WeaponProgression:GetDescendants()) do
			if v:IsA("IntValue") then
				if v.Value == Player.PlayerData.Level.Value then
					Evt.RankUp:FireClient(Player,"GunUnlock",v.Title.Value,Player.PlayerData.WeaponLevels[GunName].Value)
				end
			end
		end
		for i,v in pairs(RS.KitProgression:GetDescendants()) do
			if v:IsA("IntValue") then
				if v.Value == Player.PlayerData.Level.Value then
					Evt.RankUp:FireClient(Player,"KitUnlock",v.Title.Value,Player.PlayerData.Level.Value)
				end
			end
		end
		for i,v in pairs(RS.GrenadeProgression:GetDescendants()) do
			if v:IsA("IntValue") then
				if v.Value == Player.PlayerData.Level.Value then
					Evt.RankUp:FireClient(Player,"GrenadeUnlock",v.Title.Value,Player.PlayerData.Level.Value)
				end
			end
		end
	else
		Player.PlayerData.Level.Xp.Value = Player.PlayerData.Level.Xp.Value + Xp
	end
	
	
	if Player.PlayerData.WeaponLevels[GunName].Xp.Value + Xp > 500 then
		Player.PlayerData.WeaponLevels[GunName].Value = Player.PlayerData.WeaponLevels[GunName].Value + 1
		Player.PlayerData.WeaponLevels[GunName].Xp.Value = Player.PlayerData.WeaponLevels[GunName].Xp.Value + Xp - 500
		Evt.RankUp:FireClient(Player,"Gun",GunName,Player.PlayerData.WeaponLevels[GunName].Value)
		
		for i,v in pairs(Engine.AttModules[Settings.WeaponType]:GetDescendants()) do
			if v:IsA("ModuleScript") and CheckForAtt(Engine.GunModels[GunName],v.Parent.Name,v.Name) then
				if v.Level.Value == Player.PlayerData.WeaponLevels[GunName].Value then
					Evt.RankUp:FireClient(Player,"AttUnlock",v.Name,Player.PlayerData.WeaponLevels[GunName].Value)
				end
			end
		end
		
	else
		Player.PlayerData.WeaponLevels[GunName].Xp.Value = Player.PlayerData.WeaponLevels[GunName].Xp.Value + Xp
	end
	
	if Player.Team.TeamColor == BrickColor.new("Navy blue") then
		if RS.Team1Score.Value < RS.MaxScore.Value then
			RS.Team1Score.Value += 1
		end
	elseif Player.Team.TeamColor == BrickColor.new("Maroon") then
		if RS.Team2Score.Value < RS.MaxScore.Value then
			RS.Team2Score.Value += 1
		end
	end
end

function PlayCharacterSound(Character,SoundType)
	if SoundType == "Hit" and Character.Humanoid.Health < 20 then
		SoundType = "HitBad"
	end
	
	local ChanceToPlay = math.random(1,3)
	if ChanceToPlay == 1 or SoundType == "Died" then
		print(SoundType)
		if Character:FindFirstChild("Head") and Character:FindFirstChild("CharacterSounds") and #Character.CharacterSounds[SoundType]:GetChildren() > 0 then
			if Character.Head:FindFirstChild(SoundType.."_Sound") then
				return
			end
			--if SoundType == "Hit" or SoundType == "HitBad" then
			--	if Character.Head:FindFirstChild("Suppressed_Sound") then
			--		Character.Head.Suppressed_Sound:Destroy()
			--	end
			--end
			if SoundType == "Died" then
				if Character.Head:FindFirstChild("Suppressed_Sound") then
					Character.Head.Suppressed_Sound:Destroy()
				elseif Character.Head:FindFirstChild("Hit_Sound") then
					Character.Head.Hit_Sound:Destroy()
				elseif Character.Head:FindFirstChild("HitBad_Sound") then
					Character.Head.HitBad_Sound:Destroy()
				end
			end
			local SoundFolder = Character.CharacterSounds[SoundType]
			local RandomSound = SoundFolder:GetChildren()[math.random(1,#SoundFolder:GetChildren())]:Clone()
			RandomSound.Name = SoundType.."_Sound"
			RandomSound.Parent = Character.Head
			RandomSound:Play()
			RandomSound.Ended:Connect(function()
				RandomSound:Destroy()
			end)
		end
	end
end



--function StreakUpdate(P)
--	local S1 = P.PlayerData.Streaks.Streak1.Value
--	local S2 = P.PlayerData.Streaks.Streak2.Value
--	local S3 = P.PlayerData.Streaks.Streak3.Value
--	local S1Kills = RS.Streaks.Slot1[S1].Kills.Value or nil
--	local S2Kills = RS.Streaks.Slot2[S2].Kills.Value or nil
--	local S3Kills = RS.Streaks.Slot3[S3].Kills.Value or nil
--	local CurrentStreak = P.PlayerData.Streak.Value
--	if CurrentStreak == S1Kills then
--		P.PlayerData.Streaks.Uses.Streak1.Value = true
--	end
--	if CurrentStreak == S2Kills then
--		P.PlayerData.Streaks.Uses.Streak2.Value = true
--	end
--	if CurrentStreak == S3Kills then
--		P.PlayerData.Streaks.Uses.Streak3.Value = true
--	end
--end

function CalculateDMG(CAPlr, VictimHuman, Distance, DMGType, DMGunSettings, DMModTable,ArchetypeData,ShieldHealth,EnemyType,ShieldType)

	local DealPlayer	= nil
	local Damage = 0
	local skp_2 = 0

	if game.Players:GetPlayerFromCharacter(VictimHuman.Parent) ~= nil then
		DealPlayer = game.Players:GetPlayerFromCharacter(VictimHuman.Parent)
	end

	if DMGType == 1 then
		local skp_3 = ((ArchetypeData.Impact + DMGunSettings.Impact)*ArchetypeData.WeaponMod * (ArchetypeData.CritMultiply * DMGunSettings.CritMultiply))
		Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))
		
		if Distance > (DMGunSettings.FallOfDistance + ArchetypeData.FallOfDistance) * DMModTable.FallOfRangeMod then
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))
		else
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) - (Distance/25) * (DMGunSettings.DamageFallOf*ArchetypeData.DamageFallOf)* DMModTable.FallOfDamageMod + 0.5))  
		end
		if DealPlayer ~= nil then
			if DealPlayer.Team ~= CAPlr.Team or DealPlayer.Neutral == true then
				VictimHuman:TakeDamage(Damage)
				Evt.HitMarker:FireClient(CAPlr,"Head",Damage)
				if VictimHuman.Health <= 0 and DealPlayer.PlayerData.Spawned.Value == true then
					DealPlayer.PlayerData.Spawned.Value = false
					Evt.Xp:FireClient(CAPlr,"Head")
					GiveXp(CAPlr,"Head",DMGunSettings.gunName,DMGunSettings)
					--CAPlr.PlayerData.Streak.Value += 1
					--StreakUpdate(CAPlr)
				end
			end
		else
			if VictimHuman.Parent.EnemyData.Team.Value ~= CAPlr.Team.Name then
				VictimHuman:TakeDamage(Damage)
				Evt.HitMarker:FireClient(CAPlr,"Head",Damage)
				if VictimHuman.Health <= 0 and VictimHuman.Parent.EnemyData.Spawned.Value == true then
					VictimHuman.Parent.EnemyData.Spawned.Value = false
					Evt.Xp:FireClient(CAPlr,"Head")
					GiveXp(CAPlr,"Head",DMGunSettings.gunName,DMGunSettings)
					--CAPlr.PlayerData.Streak.Value += 1
					--StreakUpdate(CAPlr)
				end
			end
		end
		if VictimHuman.Health > 0 then
			PlayCharacterSound(VictimHuman.Parent,"Hit")
		end
	elseif DMGType == 2 then
		local skp_3 = (ArchetypeData.Impact + DMGunSettings.Impact)*ArchetypeData.WeaponMod
		Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))

		if Distance > (DMGunSettings.FallOfDistance + ArchetypeData.FallOfDistance) * DMModTable.FallOfRangeMod then
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))
		else
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) - (Distance/25) * (DMGunSettings.DamageFallOf*ArchetypeData.DamageFallOf)* DMModTable.FallOfDamageMod + 0.5))  
		end
		if DealPlayer ~= nil then
			if DealPlayer.Team ~= CAPlr.Team or DealPlayer.Neutral == true then
				VictimHuman:TakeDamage(Damage)
				Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
				if VictimHuman.Health <= 0 and DealPlayer.PlayerData.Spawned.Value == true then
					DealPlayer.PlayerData.Spawned.Value = false
					Evt.Xp:FireClient(CAPlr,"Body")
					GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
					--CAPlr.PlayerData.Streak.Value += 1
					--StreakUpdate(CAPlr)
				end
			end
		else
			if VictimHuman.Parent.EnemyData.Team.Value ~= CAPlr.Team.Name then
			VictimHuman:TakeDamage(Damage)
			Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
			if VictimHuman.Health <= 0 and VictimHuman.Parent.EnemyData.Spawned.Value == true then
				VictimHuman.Parent.EnemyData.Spawned.Value = false
				Evt.Xp:FireClient(CAPlr,"Body")
				GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
				--CAPlr.PlayerData.Streak.Value += 1
				--StreakUpdate(CAPlr)
				end
			end
			
		end
		if VictimHuman.Health > 0 then
			PlayCharacterSound(VictimHuman.Parent,"Hit")
		end
	elseif DMGType == 3 then
		local skp_3 = 30
		Damage = 30

		if DealPlayer ~= nil then
			if DealPlayer.Team ~= CAPlr.Team or DealPlayer.Neutral == true then
				VictimHuman:TakeDamage(Damage)
				Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
				if VictimHuman.Health <= 0 and DealPlayer.PlayerData.Spawned.Value == true then
					DealPlayer.PlayerData.Spawned.Value = false
					Evt.Xp:FireClient(CAPlr,"Body")
					GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
					--CAPlr.PlayerData.Streak.Value += 1
					--StreakUpdate(CAPlr)
				end
			end
		else
			if VictimHuman.Parent.EnemyData.Team.Value ~= CAPlr.Team.Name then
			VictimHuman:TakeDamage(Damage)
			Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
			if VictimHuman.Health <= 0 and VictimHuman.Parent.EnemyData.Spawned.Value == true then
				VictimHuman.Parent.EnemyData.Spawned.Value = false
				Evt.Xp:FireClient(CAPlr,"Body")
				GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
				--CAPlr.PlayerData.Streak.Value += 1
				--StreakUpdate(CAPlr)
				end
			end
			
		end
		if VictimHuman.Health > 0 then
			PlayCharacterSound(VictimHuman.Parent,"Hit")
		end
	end	
end

function CalculateJetDMGD(CAPlr, VictimJet, Distance, DMGType, DMGunSettings, DMModTable,ArchetypeData,ShieldHealth,EnemyType,ShieldType)
	local Damage = 0
	local skp_2 = 0

	if DMGType == 1 then
		print("Sending Drone Damage")
		local skp_3 = ((ArchetypeData.Impact + DMGunSettings.Impact)*ArchetypeData.WeaponMod * (ArchetypeData.CritMultiply * DMGunSettings.CritMultiply))
		Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))

		if Distance > (DMGunSettings.FallOfDistance + ArchetypeData.FallOfDistance) * DMModTable.FallOfRangeMod then
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) + 0.5))
		else
			Damage = math.max(skp_2 ,math.floor((skp_3 * DMModTable.DamageMod) - (Distance/25) * (DMGunSettings.DamageFallOf*ArchetypeData.DamageFallOf)* DMModTable.FallOfDamageMod + 0.5)) 
		end
		
		if VictimJet.Info.Team.Value ~= CAPlr.Team.Name then
			
			if VictimJet.Info.Health.Value - Damage < 0 then
				VictimJet.Info.Health.Value = 0
			else
				
				VictimJet.Info.Health.Value -= Damage
			end
			Evt.HitMarker:FireClient(CAPlr,"Head",Damage)
			if VictimJet.Info.Health.Value <= 0 then
				Evt.Xp:FireClient(CAPlr,"Head")
				--StreakUpdate(CAPlr)
			end
		end
	end
end

function CalculateJetDMGDfromJet(CAPlr, VictimJet, Distance, DMGunSettings)
	local Damage = 0
	local skp_2 = 0


	local skp_3 = (DMGunSettings.Impact)
	Damage = math.max(skp_2 ,math.floor((skp_3) + 0.5))

	if Distance > (DMGunSettings.FallOfDistance) then
		Damage = math.max(skp_2 ,math.floor((skp_3) + 0.5))/10 
	else
		Damage = math.max(skp_2 ,math.floor((skp_3) - (Distance/25) * (DMGunSettings.DamageFallOf) + 0.5))/10 
	end
		if VictimJet.Info.Team.Value ~= CAPlr.Team.Name then

			if VictimJet.Info.Health.Value - Damage < 0 then
			VictimJet.Info.Health.Value = 0
			else
			VictimJet.Info.Health.Value -= Damage
			end
			Evt.HitMarker:FireClient(CAPlr,"Head",Damage)
		if VictimJet.Info.Health.Value <= 0 then
				Evt.Xp:FireClient(CAPlr,"Jet")
				--StreakUpdate(CAPlr)
			end
		end
end

function CalculateJetDMG(CAPlr, VictimHuman, Distance, DMGunSettings)

	local DealPlayer	= nil
	local Damage = 0
	local skp_2 = 0

	if game.Players:GetPlayerFromCharacter(VictimHuman.Parent) ~= nil then
		DealPlayer = game.Players:GetPlayerFromCharacter(VictimHuman.Parent)
	end

	local skp_3 = (DMGunSettings.Impact)
	Damage = math.max(skp_2 ,math.floor((skp_3) + 0.5))

	if Distance > (DMGunSettings.FallOfDistance) then
		Damage = math.max(skp_2 ,math.floor((skp_3) + 0.5))
	else
		Damage = math.max(skp_2 ,math.floor((skp_3) - (Distance/25) * (DMGunSettings.DamageFallOf) + 0.5))  
	end
	if DealPlayer ~= nil then
		if DealPlayer.Team ~= CAPlr.Team or DealPlayer.Neutral == true then
			VictimHuman:TakeDamage(Damage)
			Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
			if VictimHuman.Health <= 0 and DealPlayer.PlayerData.Spawned.Value == true then
				DealPlayer.PlayerData.Spawned.Value = false
				Evt.Xp:FireClient(CAPlr,"Jet")
				--GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
				--CAPlr.PlayerData.Streak.Value += 1
				--StreakUpdate(CAPlr)
				print("Got Kill")
			end
		end
	else
		VictimHuman:TakeDamage(Damage)
		Evt.HitMarker:FireClient(CAPlr,"Body",Damage)
		if VictimHuman.Health <= 0 and VictimHuman.Parent.EnemyData.Spawned.Value == true then
			VictimHuman.Parent.EnemyData.Spawned.Value = false
			Evt.Xp:FireClient(CAPlr,"Jet")
			--GiveXp(CAPlr,"Body",DMGunSettings.gunName,DMGunSettings)
			--CAPlr.PlayerData.Streak.Value += 1
			--StreakUpdate(CAPlr)
			print("Got Kill")
		end
	end
	if VictimHuman.Health > 0 then
		PlayCharacterSound(VictimHuman.Parent,"Hit")
	end
end

local function Damage(DMPlr, DMTool, VictimHuman, Distance, DMGType, DMGunSettings, DMModTable, SKP_7, SKP_8, SKP_9,ArchetypeData,ShieldHealth,EnemyType,ShieldType)
	if DMPlr and DMPlr.Character and DMPlr.Character.Humanoid.Health > 0 then
		if SKP_9 == (ACS_0.."-"..DMPlr.UserId) then
			if not SKP_7 then
				if DMTool then
					if DMTool:IsA("Tool") then
						local skp_0 = secureSettings(DMPlr,DMTool, DMGunSettings)
						if skp_0 and VictimHuman then
							CalculateDMG(DMPlr, VictimHuman, Distance, DMGType, DMGunSettings, DMModTable,ArchetypeData,ShieldHealth,EnemyType,ShieldType)
							local skp_1	= Instance.new("ObjectValue")
							skp_1.Name	= "creator"
							skp_1.Value	= DMPlr
							skp_1.Parent= VictimHuman
							game.Debris:AddItem(skp_1, 1)
						end
					else
						if VictimHuman then
							CalculateJetDMG(DMPlr, VictimHuman, Distance, DMGunSettings)
							local skp_1	= Instance.new("ObjectValue")
							skp_1.Name	= "creator"
							skp_1.Value	= DMPlr
							skp_1.Parent= VictimHuman
							game.Debris:AddItem(skp_1, 1)
						end
					end

				else
					DMPlr:kick("Exploit Protocol")
					warn(DMPlr.Name.." - Potential Exploiter! Case 1: Tried To Access Damage Event")
					table.insert(_G.TempBannedPlayers, DMPlr)
				end
			else
				DMPlr.Character.Humanoid:TakeDamage(SKP_8)
			end
		else
			DMPlr:kick("Exploit Protocol")
			warn(DMPlr.Name.." - Potential Exploiter! Case 0-B: Wrong Permission Code")
			table.insert(_G.TempBannedPlayers, DMPlr)
		end
	end
end


local function JetDamaged(DMPlr, DMTool, VictimJet, Distance, DMGType, DMGunSettings, DMModTable, SKP_7, SKP_8, SKP_9,ArchetypeData,ShieldHealth,EnemyType,ShieldType)
	if DMPlr and DMPlr.Character and DMPlr.Character.Humanoid.Health > 0 then
		if SKP_9 == (ACS_0.."-"..DMPlr.UserId) then
			
			if not SKP_7 then
				
				if DMTool then
					
					if DMTool:IsA("Tool") then
						local skp_0 = secureSettings(DMPlr,DMTool, DMGunSettings)
						if skp_0 and VictimJet then
							CalculateJetDMGD(DMPlr, VictimJet, Distance, DMGType, DMGunSettings, DMModTable,ArchetypeData,ShieldHealth,EnemyType,ShieldType)
							local skp_1	= Instance.new("ObjectValue")
							skp_1.Name	= "creator"
							skp_1.Value	= DMPlr
							skp_1.Parent= VictimJet
							game.Debris:AddItem(skp_1, 1)
						end
					else
						if VictimJet then
							CalculateJetDMGDfromJet(DMPlr, VictimJet, Distance, DMGunSettings)
							local skp_1	= Instance.new("ObjectValue")
							skp_1.Name	= "creator"
							skp_1.Value	= DMPlr
							skp_1.Parent= VictimJet
							game.Debris:AddItem(skp_1, 1)
						end
					end

				else
					DMPlr:kick("Exploit Protocol")
					warn(DMPlr.Name.." - Potential Exploiter! Case 1: Tried To Access Damage Event")
					table.insert(_G.TempBannedPlayers, DMPlr)
				end
			else
				DMPlr.Character.Humanoid:TakeDamage(SKP_8)
			end
		else
			DMPlr:kick("Exploit Protocol")
			warn(DMPlr.Name.." - Potential Exploiter! Case 0-B: Wrong Permission Code")
			table.insert(_G.TempBannedPlayers, DMPlr)
		end
	end
end

Evt.Ping.OnServerInvoke = function(player, x, y, z, Tcolor)
	Evt.Pings:FireAllClients(x, y ,z, Tcolor)
end

Evt.SVReload.OnServerEvent:Connect(function(player, char, AnimData, WeaponTool)
	Evt.SVReload:FireAllClients(player, char, AnimData, WeaponTool)
end)

function BreakGlass(HitPart,Position,cPos)
	local sounds = Engine.FX.GlassBreak:GetChildren()
	local sound = sounds[math.random(1,#sounds)]:Clone()
	sound.Name = "BreakSound"
	sound.Parent = HitPart

	local breakPoint = Instance.new("Attachment")
	breakPoint.Name = "BreakingPoint"
	breakPoint.Parent = HitPart
	breakPoint.WorldPosition = Position

	if cPos then breakPoint.Position = cPos end

	local config = Mods:WaitForChild("PartFractureModule").Configuration:Clone()
	config.Parent = HitPart
	config.DebrisDespawnDelay.Value = gameRules.ShardDespawn

	local hParent = HitPart.Parent
	local shards = Fracture.FracturePart(HitPart)
	table.insert(dParts.Glass,{HitPart:Clone(),hParent,shards})

	for _, shard in pairs(shards) do
		local forceAtt = Instance.new("Attachment",shard)
		forceAtt.WorldPosition = Position

		local pushForce = Instance.new("VectorForce")
		pushForce.Enabled = true
		pushForce.Force = Vector3.new(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		pushForce.Attachment0 = forceAtt
		pushForce.Parent = forceAtt

		Debris:AddItem(forceAtt,0.1)
		Debris:AddItem(shard,gameRules.ShardDespawn)
	end
end

function BreakBricks(HitPart,Position,cPos)
	local sounds = Engine.FX.BrickBreak:GetChildren()
	local sound = sounds[math.random(1,#sounds)]:Clone()
	sound.Name = "BreakSound"
	sound.Parent = HitPart

	local breakPoint = Instance.new("Attachment")
	breakPoint.Name = "BreakingPoint"
	breakPoint.Parent = HitPart
	breakPoint.WorldPosition = Position

	if cPos then breakPoint.Position = cPos end

	local config = Mods:WaitForChild("BrickFractureModule").Configuration:Clone()
	config.Parent = HitPart
	config.DebrisDespawnDelay.Value = gameRules.ShardDespawn

	local hParent = HitPart.Parent
	local shards = BrickFracture.FracturePart(HitPart)
	table.insert(dParts.Glass,{HitPart:Clone(),hParent,shards})

	for _, shard in pairs(shards) do
		local forceAtt = Instance.new("Attachment",shard)
		forceAtt.WorldPosition = Position

		local pushForce = Instance.new("VectorForce")
		pushForce.Enabled = true
		pushForce.Force = Vector3.new(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		pushForce.Attachment0 = forceAtt
		pushForce.Parent = forceAtt

		Debris:AddItem(forceAtt,0.1)
		Debris:AddItem(shard,gameRules.ShardDespawn)
	end
end

function BreakSupport(HitPart)
	local sounds = Engine.FX.BrickBreak:GetChildren()
	local sound = sounds[math.random(1,#sounds)]:Clone()
	sound.Name = "BreakSound"
	sound.Parent = HitPart

	local config = Mods:WaitForChild("DestroySupports").Configuration:Clone()
	config.Parent = HitPart
	config.DebrisDespawnDelay.Value = gameRules.ShardDespawn

	local hParent = HitPart.Parent
	local Building = DestroySupports.FracturePart(HitPart)
end

function BreakTree(HitPart,Type)
	local sounds = Engine.FX.WoodBreak:GetChildren()
	local sound = sounds[math.random(1,#sounds)]:Clone()
	sound.Name = "BreakSound"
	sound.Parent = HitPart
	if Type == 1 then

		
		
		local Branch = HitPart.Parent
		
		if HitPart.Name == "Branch1" then
			for i,v in pairs(Branch:GetChildren()) do
				if v:IsA("BasePart") then
					v.Anchored = false
					if v:FindFirstChild("LeafEmitter") then
						v.LeafEmitter:Destroy()
						v.Name = "Leaf"
						local W = Instance.new("WeldConstraint",v)
						W.Part0 = v
						W.Part1 = v.Parent:FindFirstChild("Branch2") or v.Parent:FindFirstChild("Branch1")
						TS:Create(v,TweenInfo.new(3),{Transparency = 1}):Play()
						Debris:AddItem(v,3)
					else
						local T = math.random (10,15)
						task.delay(T-1,function()
							TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{Transparency = 1}):Play()
						end)
						Debris:AddItem(v,T)
					end
				end
			end
		elseif HitPart.Name == "Branch2" then
			for i,v in pairs(Branch:GetChildren()) do
				if v:IsA("BasePart") and v.Name ~= "Branch1" then
					v.Anchored = false
					if v:FindFirstChild("LeafEmitter") then
						v.LeafEmitter:Destroy()
						v.Name = "Leaf"
						local W = Instance.new("WeldConstraint",v)
						W.Part0 = v
						W.Part1 = v.Parent:FindFirstChild("Branch2") or v.Parent:FindFirstChild("Branch1")
						TS:Create(v,TweenInfo.new(3),{Transparency = 1}):Play()
						Debris:AddItem(v,3)
					else
						local T = math.random (10,15)
						task.delay(T-1,function()
							TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{Transparency = 1}):Play()
						end)
						Debris:AddItem(v,T)
					end
				end
			end
		end
	elseif Type == 2 then
		local Tree = HitPart.Parent
		if HitPart.Name == "TreeBase" then
			for i,v in pairs(Tree:GetDescendants()) do
				if v:IsA("BasePart") then
					v.Anchored = false
					if v:FindFirstChild("LeafEmitter") then
						v.LeafEmitter:Destroy()
						v.Name = "Leaf"
						local W = Instance.new("WeldConstraint",v)
						W.Part0 = v
						W.Part1 = v.Parent:FindFirstChild("Branch2") or v.Parent:FindFirstChild("Branch1")
						TS:Create(v,TweenInfo.new(3),{Transparency = 1}):Play()
						Debris:AddItem(v,3)
					else
						local T = math.random (10,15)
						task.delay(T-1,function()
							TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{Transparency = 1}):Play()
						end)
						Debris:AddItem(v,T)
					end
				end
			end
		elseif HitPart.Name == "TreeCore" then
			for i,v in pairs(Tree:GetDescendants()) do
				if v:IsA("BasePart") and v.Name ~= "TreeBase" then
					v.Anchored = false
					if v:FindFirstChild("LeafEmitter") then
						v.LeafEmitter:Destroy()
						v.Name = "Leaf"
						local W = Instance.new("WeldConstraint",v)
						W.Part0 = v
						W.Part1 = v.Parent:FindFirstChild("Branch2") or v.Parent:FindFirstChild("Branch1")
						TS:Create(v,TweenInfo.new(3),{Transparency = 1}):Play()
						Debris:AddItem(v,3)
					else
						local T = math.random (10,15)
						task.delay(T-1,function()
							TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{Transparency = 1}):Play()
						end)
						Debris:AddItem(v,T)
					end
				end
			end
		end
	end
end

Evt.Damage.OnServerInvoke = Damage
Evt.JetDamage.OnServerInvoke = JetDamaged

local SPEED_OF_SOUND = 343 -- meters per second at sea level
local REALISTIC_AUDIO_THRESHOLD = 150 -- distance in studs below which audio is default
local DISTANCE_MULTIPLIER = 0.28 -- convert studs to meters (1 stud â‰ˆ 0.28 meters)

-- Function to calculate audio travel delay based on distance
local function CalculateAudioDelay(distance)
	if distance < REALISTIC_AUDIO_THRESHOLD then
		return 0 -- No delay under threshold
	end

	local distanceInMeters = distance * DISTANCE_MULTIPLIER
	local delay = distanceInMeters / SPEED_OF_SOUND
	return delay
end

-- Function to apply frequency-dependent attenuation to echo sounds
local function ApplyFrequencyAttenuation(sound, distance)
	if distance < REALISTIC_AUDIO_THRESHOLD then
		return -- No modification under threshold
	end

	-- Ensure the sound has an EqualizerSoundEffect
	local equalizer = sound:FindFirstChildOfClass("EqualizerSoundEffect")
	if not equalizer then
		equalizer = Instance.new("EqualizerSoundEffect", sound)
	end

	-- Calculate attenuation based on distance
	-- Higher frequencies (HighGain) attenuate more over distance
	-- Lower frequencies (LowGain) travel further
	local distanceFactor = math.clamp((distance - REALISTIC_AUDIO_THRESHOLD) / 500, 0, 1)

	-- Attenuate high frequencies more aggressively with distance
	equalizer.HighGain = math.max(-80, -10 - (distanceFactor * 50))

	-- Mid frequencies attenuate moderately
	equalizer.MidGain = math.max(-80, -5 - (distanceFactor * 30))

	-- Low frequencies remain relatively unaffected
	equalizer.LowGain = math.max(-20, 0 - (distanceFactor * 15))
end

-- Function to play sound with realistic delay and frequency response
local function PlaySoundWithRealism(sound, distance, isSuppressed)
	if not sound then return end

	local delay = CalculateAudioDelay(distance)

	if delay > 0 then
		-- Apply frequency attenuation for echo sounds
		if sound.Name:find("Echo") then
			ApplyFrequencyAttenuation(sound, distance)
		end

		-- Schedule sound playback after travel delay
		task.delay(delay, function()
			if sound and sound.Parent then
				sound:Play()
			end
		end)
	else
		-- Play immediately for close range
		sound:Play()
	end
end

Evt.HitEffect.OnServerEvent:Connect(function(Player, Position, HitPart, Normal, Material, Settings, ArchetypeData, AmmoData,TotalDistTraveled)
	Evt.HitEffect:FireAllClients(Player, Position, HitPart, Normal, Material, Settings, ArchetypeData, AmmoData,TotalDistTraveled)
	
	if AmmoData and AmmoData.ExplosiveAmmo then
		ArchetypeData = AmmoData
	end
	-- Explosion
	if ArchetypeData.ExplosiveAmmo and ((TotalDistTraveled and TotalDistTraveled > 20) or not TotalDistTraveled) then
		
		
		for _, cPlr in pairs(plr:GetPlayers()) do
			if cPlr.Character and cPlr.Character:FindFirstChild("HumanoidRootPart") then
				local dist = (cPlr.Character.HumanoidRootPart.Position - Position).Magnitude
				local MaxZone = ArchetypeData.ExplosionRadius
				local MinZone = MaxZone / 3

				if cPlr == Player or gameRules.TeamKill or cPlr.Team ~= Player.Team or cPlr.Neutral then
					if dist < ArchetypeData.ExplosionRadius / 3 then
						-- Too close!
						cPlr.Character.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage)

						local Pushback = Instance.new("VectorForce")
						Pushback.Force = (cPlr.Character.HumanoidRootPart.Position - Position).Unit * 8000 * ArchetypeData.ExplosionKnockback
						Pushback.Parent = cPlr.Character.UpperTorso
						Pushback.Attachment0 = cPlr.Character.UpperTorso.BodyFrontAttachment
						--Pushback.ApplyAtCenterOfMass = true
						Debris:AddItem(Pushback,0.1)
						
						if cPlr ~= Player then
						Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage)
						if cPlr.Character.Humanoid.Health <= 0 and cPlr.PlayerData.Spawned.Value == true then
							cPlr.PlayerData.Spawned.Value = false
							Evt.Xp:FireClient(Player,"Body")
							GiveXp(Player,"Body",Settings.gunName,Settings)
							end
						end
						
					else
						local hit = Shrapnel.CastToTarget(Position,cPlr.Character.HumanoidRootPart.Position,5,ArchetypeData.ExplosionRadius / 2,{})
						if hit then
							local dMult = ((Position - hit.Position).Magnitude + MinZone) / (MaxZone + MinZone)

							cPlr.Character.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))
							
							if cPlr ~= Player then
								Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))
								if cPlr.Character.Humanoid.Health <= 0 and cPlr.PlayerData.Spawned.Value == true then
									cPlr.PlayerData.Spawned.Value = false
									Evt.Xp:FireClient(Player,"Body")
									GiveXp(Player,"Body",Settings.gunName,Settings)
								end
							end

						end
					end
					if dist < ArchetypeData.ExplosionRadius * 2.4 then
						local Factor = (dist/ArchetypeData.ExplosionRadius)
						Evt.Suppression:FireClient(cPlr,2,Factor,Factor)
						Evt.Quake:FireClient(cPlr,Position,ArchetypeData.ExplosionKnockback*2)
					end
				end
			end
		end
		for _, cPlr in pairs(workspace.Team1:GetChildren()) do
			if cPlr:FindFirstChild("EnemyData") and cPlr:FindFirstChild("HumanoidRootPart") and cPlr:FindFirstChild("Humanoid").Health > 0 then
				local dist = (cPlr.HumanoidRootPart.Position - Position).Magnitude
				local MaxZone = ArchetypeData.ExplosionRadius
				local MinZone = MaxZone / 3

				if gameRules.TeamKill or cPlr.EnemyData.Team.Value ~= Player.Team.Name then
					if dist < ArchetypeData.ExplosionRadius / 3 then
						-- Too close!
						cPlr.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage)

						local Pushback = Instance.new("VectorForce")
						Pushback.Force = (cPlr.HumanoidRootPart.Position - Position).Unit * 8000 * ArchetypeData.ExplosionKnockback
						Pushback.Parent = cPlr.UpperTorso
						Pushback.Attachment0 = cPlr.UpperTorso.BodyFrontAttachment
						--Pushback.ApplyAtCenterOfMass = true
						Debris:AddItem(Pushback,0.1)

						Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage)
						if cPlr.Humanoid.Health <= 0 and cPlr.EnemyData.Spawned.Value == true then
							cPlr.EnemyData.Spawned.Value = false
							Evt.Xp:FireClient(Player,"Body")
							GiveXp(Player,"Body",Settings.gunName,Settings)
						end
					else
						local hit = Shrapnel.CastToTarget(Position,cPlr.HumanoidRootPart.Position,5,ArchetypeData.ExplosionRadius / 2,{})
						if hit then
							local dMult = ((Position - hit.Position).Magnitude + MinZone) / (MaxZone + MinZone)

							cPlr.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))

							Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))
							if cPlr.Humanoid.Health <= 0 and cPlr.EnemyData.Spawned.Value == true then
								cPlr.EnemyData.Spawned.Value = false
								Evt.Xp:FireClient(Player,"Body")
								GiveXp(Player,"Body",Settings.gunName,Settings)
							end
						end
					end
				end
			end
		end

		for _, cPlr in pairs(workspace.Team2:GetChildren()) do
			if cPlr:FindFirstChild("EnemyData") and cPlr:FindFirstChild("HumanoidRootPart") and cPlr:FindFirstChild("Humanoid").Health > 0 then
				local dist = (cPlr.HumanoidRootPart.Position - Position).Magnitude
				local MaxZone = ArchetypeData.ExplosionRadius
				local MinZone = MaxZone / 3

				if gameRules.TeamKill or cPlr.EnemyData.Team.Value ~= Player.Team.Name then
					if dist < ArchetypeData.ExplosionRadius / 3 then
						-- Too close!
						cPlr.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage)

						local Pushback = Instance.new("VectorForce")
						Pushback.Force = (cPlr.HumanoidRootPart.Position - Position).Unit * 8000 * ArchetypeData.ExplosionKnockback
						Pushback.Parent = cPlr.UpperTorso
						Pushback.Attachment0 = cPlr.UpperTorso.BodyFrontAttachment
						--Pushback.ApplyAtCenterOfMass = true
						Debris:AddItem(Pushback,0.1)

						Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage)
						if cPlr.Humanoid.Health <= 0 and cPlr.EnemyData.Spawned.Value == true then
							cPlr.EnemyData.Spawned.Value = false
							Evt.Xp:FireClient(Player,"Body")
							GiveXp(Player,"Body",Settings.gunName,Settings)
						end
					else
						local hit = Shrapnel.CastToTarget(Position,cPlr.HumanoidRootPart.Position,5,ArchetypeData.ExplosionRadius / 2,{})
						if hit then
							local dMult = ((Position - hit.Position).Magnitude + MinZone) / (MaxZone + MinZone)

							cPlr.Humanoid:TakeDamage(ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))

							Evt.HitMarker:FireClient(Player,"Body",ArchetypeData.ExplosionDamage - (ArchetypeData.ExplosionDamage * dMult))
							if cPlr.Humanoid.Health <= 0 and cPlr.EnemyData.Spawned.Value == true then
								cPlr.EnemyData.Spawned.Value = false
								Evt.Xp:FireClient(Player,"Body")
								GiveXp(Player,"Body",Settings.gunName,Settings)
							end
						end
					end
				end
			end
		end

		-- Explosion fx
		local expFX
		if Engine.HITFX.Explosion:FindFirstChild(ArchetypeData.ExplosionType) then

			expFX = Engine.HITFX.Explosion[ArchetypeData.ExplosionType]

		else
			expFX = Engine.HITFX.Explosion.Default
		end

		local effectAtt = Instance.new("Attachment",workspace.Terrain)
		effectAtt.WorldCFrame = CFrame.new(Position) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
		local echo = expFX.Echo:Clone()
		local exp = expFX.Explosion:Clone()
		
		echo.Parent = effectAtt
		exp.Parent = effectAtt
		
		Evt.LocalExplosion:FireAllClients(effectAtt)
		
		local Explos = Instance.new("Explosion")
		Explos.BlastRadius = ArchetypeData.ExplosionRadius/4
		Explos.BlastPressure = 1
		Explos.DestroyJointRadiusPercent = 0
		Explos.ExplosionType = Enum.ExplosionType.Craters
		Explos.Position = effectAtt.WorldPosition
		Explos.Visible = false
		Explos.Parent = workspace.Terrain

		--local exp2 = exp:Clone()
		--exp2.Parent = effectAtt
		--exp2.SoundId = Explosion[math.random(1,#Explosion)]
		--exp2:Play()
		for _, fx in pairs(expFX:GetChildren()) do
			if fx:IsA("ParticleEmitter") and fx:FindFirstChild("Amount") then
				local nEffect = fx:Clone()
				nEffect.Parent = effectAtt
				nEffect:Emit(nEffect.Amount.Value)
			end
		end

		Debris:AddItem(effectAtt, ArchetypeData.ExplosionLifetime or 120)

		-- Break nearby glass
		if gameRules.BreakGlass then
			local rParts = workspace:GetPartBoundsInRadius(Position,ArchetypeData.ExplosionRadius,gBreakParam)
			for i, cPart in pairs(rParts) do
				--print(cPart.Name)
				if i % 30 == 0 then 
					wait(0.05)
				end
				if cPart.Name == gameRules.GlassName and cPart:IsA("Part") then
					local size = 0.8 * cPart.Size * (math.random(-10,10) / 10)
					BreakGlass(cPart,Position,Vector3.new(0.2,0.2,0.2))
					wait()
				end
				if cPart.Name == "Light" and cPart:IsA("Part") and cPart:FindFirstChild("PointLight") and cPart.PointLight.Enabled == true then
					local newSound = Engine.FX.LightBreak:Clone()
					newSound.PlayOnRemove = true
					newSound.Parent = cPart
					newSound:Destroy()
					
					local light = cPart.PointLight


					cPart.Material = Enum.Material.Metal
					light.Enabled = false
				end
				if cPart.Name == "Bricks" and cPart:IsA("Part") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius/3 then

					local size = 0.8 * cPart.Size * (math.random(-10,10) / 10)
					BreakBricks(cPart,Position,Vector3.new(0.2,0.2,0.2))
					wait()
				end
				if cPart.Name == "Support" and cPart:IsA("Part") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius/4 then

					BreakSupport(cPart)
					wait()
				end
				if cPart.Name == "Weight" and cPart:IsA("Part") and cPart.Parent and (cPart.Parent.Name == "Spinner" or cPart.Parent.Name == "Crane") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius then

					local size = 0.8 * cPart.Size * (math.random(-10,10) / 10)
					BreakBricks(cPart,Position,Vector3.new(0.2,0.2,0.2))
					wait()
				elseif cPart.Name == "Weight" and cPart:IsA("BasePart") and cPart.Parent and (cPart.Parent.Name == "TransmissionTower") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius*2 then
					cPart.Anchored = false
					Debris:AddItem(cPart,5)
					wait()
				end
				if string.match(cPart.Name,"Branch") and cPart.Parent and cPart.Parent.Parent and cPart.Parent.Parent.Name and cPart.Parent.Parent.Name == "Branches" and cPart:IsA("BasePart") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius/2 then
					print("Branch")
					BreakTree(cPart,1)
					wait()
				end
				if (cPart.Name == "TreeCore" or cPart.Name == "TreeBase") and cPart:IsA("BasePart") and (cPart.Position - Position).Magnitude < ArchetypeData.ExplosionRadius/2 then
					print("Tree")
					BreakTree(cPart,2)
					wait()
				end
				if cPart.Name == "Knob" and cPart:IsA("BasePart") then
					local DoorModel = cPart.Parent

					print("Breach")
					--BulletHole(Position,Normal,HitPart)

					if DoorModel and DoorModel:FindFirstChild("Hinge") ~= nil then
						local hingeConstraint = DoorModel.Hinge.HingeConstraint
						hingeConstraint.ActuatorType = Enum.ActuatorType.Motor
						hingeConstraint.MotorMaxTorque = 0       -- This makes it freely movable
						hingeConstraint.AngularVelocity = 0      -- No initial velocity
						--hingeConstraint.TargetAngle = 90        -- Remove target angle restriction


						-- If the door is locked, unlock it
						if DoorModel:FindFirstChild("Locked") then
							DoorModel.Locked.Value = false
						end
					end
					cPart:Destroy()
					
				end
				if cPart.Name == "DoorHinge" and cPart:IsA("BasePart") and cPart.Parent then
					local DoorModel = cPart.Parent

					--BulletHole(Position,Normal,HitPart)
					cPart:Destroy()
					if DoorModel and DoorModel:FindFirstChild("DoorHinge") == nil and DoorModel:FindFirstChild("Door") then
						DoorModel.Hinge:Destroy()
						local Door = DoorModel.Door:Clone()
						Door.CFrame = DoorModel.Door.CFrame
						Door.Parent = game.Workspace
						DoorModel.Door:Destroy()
						if DoorModel:FindFirstChild("Knob") then
							local Knob = DoorModel.Knob:Clone()
							Knob.CFrame = DoorModel.Knob.CFrame
							Knob.Parent = game.Workspace
							DoorModel.Knob:Destroy()
							local Wel = Instance.new("WeldConstraint",Knob)
							Wel.Part0 = Knob
							Wel.Part1 = Door
						end
					end
					
				end
				if cPart.Parent and cPart.Parent.Name and cPart.Parent.Name == "PhysicsObjects" and cPart:IsA("BasePart") then
					if cPart.Anchored == true then
						cPart.Anchored = false
					else
						local forceAtt = Instance.new("Attachment",cPart)
						forceAtt.WorldPosition = Position

						local pushForce = Instance.new("VectorForce")
						pushForce.Enabled = true
						pushForce.Force = (cPart.Position - Position).Unit * 1000 * ArchetypeData.ExplosionKnockback

						pushForce.Attachment0 = forceAtt
						pushForce.Parent = forceAtt

						Debris:AddItem(forceAtt,0.1)
					end

				end
				
				if cPart.Parent and cPart.Parent.Parent and cPart.Parent.Parent.Name and cPart.Parent.Parent.Name == "Cars" and cPart:IsA("BasePart") then
					if cPart.Parent:FindFirstChild("Destroyed") then
						if cPart.Parent.Destroyed.Value == false then
							local car = cPart.Parent
							cPart.Parent.Destroyed.Value = true
							for i,v in pairs(car:GetChildren()) do
								if v.Name and (v.Name == "Windows" or v.Name == "Windows2" or v.Name == "RLT" or v.Name == "RRT" or v.Name == "FRT" or v.Name == "FLT") and v:IsA("BasePart") then
									v.Transparency = 1
								elseif v.Name and (v.Name == "LeftFrontLight" or v.Name == "RightFrontLight" or v.Name == "LeftRearLight" or v.Name == "RightRearLight") and v:IsA("BasePart") then
									v.Transparency = 0.6
								end
							end
							TS:Create(car.Hood,TweenInfo.new(0.3,Enum.EasingStyle.Bounce),{CFrame = car.DestroyedHood.CFrame}):Play()
							car.SmokePart.Smoke.Enabled = true
							car.SmokePart.Alarm:Play()
							car.SmokePart.DestroySound:Play()
							Debris:AddItem(car.SmokePart,15)
						end
					end

				end
			end
		end
	end

	-- Glass breaking
	if gameRules.BreakGlass and HitPart and HitPart:IsA("Part") and HitPart.Name == gameRules.GlassName then
		BreakGlass(HitPart,Position)
	end
	

	-- Light breaking
	if gameRules.BreakLights and HitPart.Name == "Light" and not HitPart:FindFirstChild("Broken") then
		table.insert(dParts.Lights,{HitPart,Material})

		local foundALight = false
		local tag = Instance.new("BoolValue",HitPart)
		tag.Name = "Broken"
		tag.Value = true

		local lights = {}

		for _, child in pairs(HitPart:GetChildren()) do
			if child:IsA("Light") then
				table.insert(lights,child)
				foundALight = true
			end
		end

		if foundALight then
			local newSound = Engine.FX.LightBreak:Clone()
			newSound.PlayOnRemove = true
			newSound.Parent = HitPart
			newSound:Destroy()

			local originalMat = HitPart.Material

			for i = 1, math.random(3,6) do
				HitPart.Material = Enum.Material.Metal
				for _, light in pairs(lights) do
					light.Enabled = false
				end

				wait(math.random(50,1000) / 10000)

				HitPart.Material = Enum.Material.Neon
				for _, light in pairs(lights) do
					light.Enabled = true
				end

				wait(math.random(50,1000) / 10000)
			end

			HitPart.Material = Enum.Material.Metal
			for _, light in pairs(lights) do
				light.Enabled = false
			end
		end
	end
end)

Evt.GunStance.OnServerEvent:Connect(function(Player,stance,Data)
	Evt.GunStance:FireAllClients(Player,stance,Data)
end)

Evt.ServerBullet.OnServerEvent:Connect(function(Player,Origin,Direction,WeaponData,ModTable,ArchetypeData,IsUnderBarrel,Jet)
	Evt.ServerBullet:FireAllClients(Player,Origin,Direction,WeaponData,ModTable,ArchetypeData,IsUnderBarrel,Jet)
end)

Evt.ServerMissile.OnServerEvent:Connect(function(Player,Origin,Direction,WeaponData,Jet,LockTarget)
	Evt.ServerMissile:FireAllClients(Player,Origin,Direction,WeaponData,Jet,LockTarget)
end)


Evt.Stance.OnServerEvent:connect(function(Player, Stance, Virar)

	if Player.Character and Player.Character:FindFirstChild("Humanoid") ~= nil and Player.Character.Humanoid.Health > 0 then

		local char		= Player.Character
		local Human 	= char:WaitForChild("Humanoid")
		local Game_Client= char:WaitForChild("Client")

		local LowerTorso= char:FindFirstChild("LowerTorso")
		local UpperTorso= char:FindFirstChild("UpperTorso")
		local RootJoint = char["LowerTorso"]:FindFirstChild("Root")
		local WaistJ 	= char["UpperTorso"]:FindFirstChild("Waist")
		local RS 		= char["RightUpperArm"]:FindFirstChild("RightShoulder")
		local LS 		= char["LeftUpperArm"]:FindFirstChild("LeftShoulder")
		local RH 		= char["RightUpperLeg"]:FindFirstChild("RightHip")
		local RK 		= char["RightLowerLeg"]:FindFirstChild("RightKnee")
		local LH 		= char["LeftUpperLeg"]:FindFirstChild("LeftHip")
		local LK 		= char["LeftLowerLeg"]:FindFirstChild("LeftKnee")

		local RightArm	= char["RightUpperArm"]
		local LeftArm 	= char["LeftUpperArm"]
		local LeftLeg 	= char["LeftUpperLeg"]
		local RightLeg 	= char["RightUpperLeg"]


		if Stance == 2 and RootJoint and WaistJ and RH and LH and RK and LK then
			TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-Human.HipHeight - LowerTorso.Size.Y,Human.HipHeight/1.25)* CFrame.Angles(math.rad(-90),0,math.rad(0))} ):Play()
			TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
			TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.5, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.5, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
			TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()

			-- Add arm positioning for prone - angled upward
			TS:Create(RS, TweenInfo.new(.3), {C0 = CFrame.new(1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LS, TweenInfo.new(.3), {C0 = CFrame.new(-1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))} ):Play()
		end
		if Virar == 1 and RootJoint and WaistJ and RH and LH and RK and LK then
			if Stance == 0 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0) * CFrame.Angles(math.rad(0),0,math.rad(-30))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-0.5,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()

			elseif Stance == 1 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0)* CFrame.Angles(math.rad(0),0,math.rad(-30))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-Human.HipHeight/1.05,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(75),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/2,0)* CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3.5,0)* CFrame.Angles(math.rad(-60),math.rad(0),math.rad(0))} ):Play()

			end
		elseif Virar == -1 and RootJoint and WaistJ and RH and LH and RK and LK then
			if Stance == 0 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0) * CFrame.Angles(math.rad(0),0,math.rad(30))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-0.5,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()

			elseif Stance == 1 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0)* CFrame.Angles(math.rad(0),0,math.rad(30))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-Human.HipHeight/1.05,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(75),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/2,0)* CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3.5,0)* CFrame.Angles(math.rad(-60),math.rad(0),math.rad(0))} ):Play()

			end
		elseif Virar == 0 and RootJoint and WaistJ and RH and LH and RK and LK then
			if Stance == 0 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0)* CFrame.Angles(math.rad(-0),0,math.rad(0))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-0.5,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()

			elseif Stance == 1 then
				TS:Create(WaistJ, TweenInfo.new(.3), {C0 = CFrame.new(0,LowerTorso.Size.Y/2.5,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RootJoint, TweenInfo.new(.3), {C0 = CFrame.new(0,-Human.HipHeight/1.05,0)* CFrame.Angles(math.rad(0),0,math.rad(0))} ):Play()
				TS:Create(RH, TweenInfo.new(.3), {C0 = CFrame.new(0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LH, TweenInfo.new(.3), {C0 = CFrame.new(-0.6, -LowerTorso.Size.Y/2,0)* CFrame.Angles(math.rad(75),math.rad(0),math.rad(0))} ):Play()
				TS:Create(RK, TweenInfo.new(.3), {C0 = CFrame.new(0, -RightLeg.Size.Y/2,0)* CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))} ):Play()
				TS:Create(LK, TweenInfo.new(.3), {C0 = CFrame.new(0, -LeftLeg.Size.Y/3.5,0)* CFrame.Angles(math.rad(-60),math.rad(0),math.rad(0))} ):Play()

			end
		end

		if Game_Client:GetAttribute("Surrender") then
			TS:Create(RS, TweenInfo.new(.3), {C0 = CFrame.new(1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(179),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LS, TweenInfo.new(.3), {C0 = CFrame.new(-1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(179),math.rad(0),math.rad(0))} ):Play()
		elseif Stance == 2 then
			TS:Create(RS, TweenInfo.new(.3), {C0 = CFrame.new(1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(170),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LS, TweenInfo.new(.3), {C0 = CFrame.new(-1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(170),math.rad(0),math.rad(0))} ):Play()
		else
			TS:Create(RS, TweenInfo.new(.3), {C0 = CFrame.new(1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
			TS:Create(LS, TweenInfo.new(.3), {C0 = CFrame.new(-1.2, UpperTorso.Size.Y/2.8,0)* CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))} ):Play()
		end
	end
end)

Evt.Surrender.OnServerEvent:Connect(function(Player,Victim)

	local PClient 	= nil

	if Victim then
		PClient = Victim.Character:FindFirstChild("Client")

		if Victim == Player then
			return
		end

		if not PClient then
			return
		end

		if PClient:GetAttribute("Surrender") then
			PClient:SetAttribute("Surrender",false)
		end
	else
		PClient = Player.Character:FindFirstChild("Client")

		if not PClient then
			return
		end

		if not PClient:GetAttribute("Surrender") then
			PClient:SetAttribute("Surrender",true)
		end
	end
end)

Evt.Grenade.OnServerEvent:Connect(function(SKP_0, SKP_1, SKP_2, SKP_3, SKP_4, SKP_5, SKP_6, Timer,GLName)
	
	if not SKP_0 or not SKP_0.Character then 
		return; 
	end;

	if not SKP_0.Character:FindFirstChild("Humanoid") or SKP_0.Character.Humanoid.Health <= 0 then 
		return; 
	end;
	

	if SKP_6 ~= (ACS_0.."-"..SKP_0.UserId) then
		SKP_0:kick("Exploit Protocol")
		warn(SKP_0.Name.." - Potential Exploiter! Case 0-B: Wrong Permission Code")
		table.insert(_G.TempBannedPlayers, SKP_0)
		return;
	end
	
	
	if not SKP_1 or not SKP_2 then
		SKP_0:kick("Exploit Protocol")
		warn(SKP_0.Name.." - Potential Exploiter! Case 3: Tried To Access Grenade Event")
		return;
	end
	
	
	
	local skp_0 = secureSettings(SKP_0, SKP_1, SKP_2)

	if not SVGunModels:FindFirstChild(GLName) then 
		warn("ACS_Server Couldn't Find "..GLName.." In Grenade Model Folder"); 
		return; 
	end;

	local skp_0 = SVGunModels[GLName]:Clone()

	for SKP_Arg0, SKP_Arg1 in pairs(SKP_0.Character:GetChildren()) do
		if not SKP_Arg1:IsA('BasePart') then continue; end;
		local skp_1 = Instance.new("NoCollisionConstraint")
		skp_1.Parent= skp_0
		skp_1.Part0 = skp_0.PrimaryPart
		skp_1.Part1 = SKP_Arg1
	end

	local skp_1	= Instance.new("ObjectValue")
	skp_1.Name	= "creator"
	skp_1.Value	= SKP_0
	skp_1.Parent= skp_0.PrimaryPart

	skp_0.Parent 	= Game_Workspace.Server
	skp_0.PrimaryPart.CFrame = SKP_3
	skp_0.PrimaryPart:ApplyImpulse(SKP_4 * SKP_5 * skp_0.PrimaryPart:GetMass())
	skp_0.PrimaryPart:SetNetworkOwner(nil)
	skp_0.PrimaryPart.Damage.Disabled = false
	skp_0.Grenade.Timer.Value = Timer
	skp_0.Grenade.Player.Value = SKP_0
end)

function loadAttachment(weapon,WeaponData,Arma,plr)
	if not weapon or not weapon:FindFirstChild("Nodes") then return; end;
	if Arma:GetAttribute("IsLoadout") == true then
		if WeaponData.WeaponType == "Pistol" or WeaponData.WeaponType == "Rocket Launcher" then
			local Atts = plr.PlayerData.Classes[plr.PlayerData.Classes.CurrentClass.Value].Secondary
			WeaponData.SightAtt = Atts.Optic.Value
			WeaponData.BarrelAtt = Atts.Barrel.Value
			WeaponData.UnderBarrelAtt = Atts.UnderBarrel.Value
			WeaponData.OtherAtt = Atts.Other.Value
			WeaponData.AmmoAtt = Atts.Ammo.Value

			WeaponData.MagAtt = Atts.Mag.Value
			WeaponData.MuzzleAtt = Atts.Muzzle.Value
			WeaponData.StockAtt = Atts.Stock.Value
			WeaponData.BoltAtt = Atts.Bolt.Value
		else
			local Atts = plr.PlayerData.Classes[plr.PlayerData.Classes.CurrentClass.Value].Primary
			WeaponData.SightAtt = Atts.Optic.Value
			WeaponData.BarrelAtt = Atts.Barrel.Value
			WeaponData.UnderBarrelAtt = Atts.UnderBarrel.Value
			WeaponData.OtherAtt = Atts.Other.Value
			WeaponData.AmmoAtt = Atts.Ammo.Value

			WeaponData.MagAtt = Atts.Mag.Value
			WeaponData.MuzzleAtt = Atts.Muzzle.Value
			WeaponData.StockAtt = Atts.Stock.Value
			WeaponData.BoltAtt = Atts.Bolt.Value
		end
	else
		WeaponData.SightAtt = Arma:GetAttribute("SightAtt")
		WeaponData.BarrelAtt = Arma:GetAttribute("BarrelAtt")
		WeaponData.UnderBarrelAtt = Arma:GetAttribute("UnderBarrelAtt")
		WeaponData.OtherAtt = Arma:GetAttribute("OtherAtt")
		WeaponData.AmmoAtt = Arma:GetAttribute("AmmoAtt")

		WeaponData.MagAtt = Arma:GetAttribute("MagAtt")
		WeaponData.MuzzleAtt = Arma:GetAttribute("MuzzleAtt")
		WeaponData.StockAtt = Arma:GetAttribute("StockAtt")
		WeaponData.BoltAtt = Arma:GetAttribute("BoltAtt")

	end
	
	if weapon:FindFirstChild("Grenade Launcher") then
		for index, key in pairs(weapon["Grenade Launcher"]:GetDescendants()) do
			if key:IsA('BasePart') then
				key.Transparency = 1
			end
		end;
	end

	AttModels 	= Engine:WaitForChild("AttModels"):WaitForChild(WeaponData.WeaponType)
	AttModules  	= Engine:WaitForChild("AttModules"):WaitForChild(WeaponData.WeaponType)

	-- Load Barrel Attachment
	if weapon:FindFirstChild("Barrels") then
		local BarrelName = (WeaponData.BarrelAtt ~= "" and WeaponData.BarrelAtt) or "Standard Barrel"
		local selectedBarrel = weapon.Barrels:FindFirstChild(BarrelName)

		if selectedBarrel then
			-- Hide all muzzle models first
			for _, Barrel in pairs(weapon.Barrels:GetChildren()) do
				if Barrel:IsA("Folder") then
					for _, part in pairs(Barrel:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Transparency = 1
							part.CanCollide = false
						end
					end
				end
			end

			-- Move selected muzzle to weapon and make visible
			selectedBarrel.Parent = weapon
			for _, part in pairs(selectedBarrel:GetChildren()) do
				if part:IsA("MeshPart") then
					if part.Name ~= "GR" then
						part.Transparency = 0
					end
					part.Parent = weapon
				end
			end

			if selectedBarrel:FindFirstChild("Nodes") then
				for i,v in pairs(selectedBarrel.Nodes:GetChildren()) do
					if weapon.Nodes:FindFirstChild(v.Name) then
						weapon.Nodes:FindFirstChild(v.Name):Destroy()
						v.Parent = weapon.Nodes
					else
						v.Parent = weapon.Nodes
					end
				end
			end


			if selectedBarrel:FindFirstChild("BarrelPos") ~= nil then
				weapon.Handle.Muzzle.WorldCFrame = selectedBarrel.BarrelPos.CFrame
			end
		end
	end

	if weapon:FindFirstChild("Bolts") then
		local boltName = (WeaponData.BoltAtt ~= "" and WeaponData.BoltAtt) or "Standard Bolt"
		local selectedBolt = weapon.Bolts:FindFirstChild(boltName)

		if selectedBolt then
			-- Hide all magazine models first
			for _, bolt in pairs(weapon.Bolts:GetChildren()) do
				if bolt:IsA("Model") then
					for _, part in pairs(bolt:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Transparency = 1
							part.CanCollide = false
						end
					end
				end
			end

			if selectedBolt:FindFirstChild("Nodes") then
				for i,v in pairs(selectedBolt.Nodes:GetChildren()) do
					if weapon.Nodes:FindFirstChild(v.Name) then
						weapon.Nodes:FindFirstChild(v.Name):Destroy()
						v.Parent = weapon.Nodes
					else
						v.Parent = weapon.Nodes
					end
				end
			end

			-- Move selected magazine to weapon and make visible
			for _, part in pairs(selectedBolt:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
					part.Parent = weapon
				end
			end
		end
	end

	if weapon:FindFirstChild("Hammers") then
		local HammerName = (WeaponData.HammerAtt ~= "" and WeaponData.HammerAtt) or "Standard Hammer"
		local selectedHammer = weapon.Hammers:FindFirstChild(HammerName)

		if selectedHammer then
			-- Hide all magazine models first
			for _, bolt in pairs(weapon.Hammers:GetChildren()) do
				if bolt:IsA("Model") then
					for _, part in pairs(bolt:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Transparency = 1
							part.CanCollide = false
						end
					end
				end
			end

			if selectedHammer:FindFirstChild("Nodes") then
				for i,v in pairs(selectedHammer.Nodes:GetChildren()) do
					if weapon.Nodes:FindFirstChild(v.Name) then
						weapon.Nodes:FindFirstChild(v.Name):Destroy()
						v.Parent = weapon.Nodes
					else
						v.Parent = weapon.Nodes
					end
				end
			end

			-- Move selected magazine to weapon and make visible
			for _, part in pairs(selectedHammer:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
					part.Parent = weapon
				end
			end
		end
	end

	--load sight Att
	if weapon.Nodes:FindFirstChild("Sight") and WeaponData.SightAtt ~= "" then

		for index, key in pairs(weapon:GetDescendants()) do
			if key:IsA("BasePart") then
				if key.Name == "IS" then 
					key.Transparency = 1
				end;
				if key.Name == "SI" then 
					key.Transparency = 0
				end;
			end
			if key.Name == "ADS" or key.Name == "REG" or key.Name == "SightMark" or key.Name == "SightMark2" then 
				key:Destroy()
			end;
		end

		AttTable.SightAtt = AttModels[WeaponData.SightAtt]:Clone()
		AttTable.SightAtt.Parent = weapon
		for index, key in pairs(AttTable.SightAtt:GetChildren()) do
			if not key:IsA('BasePart') or key.Name == "Main" then 
				continue; 
			end;
			Ultil.Weld(AttTable.SightAtt.Main, key )
			key.Anchored = false
			key.CanCollide = false
		end

		Ultil.Weld(weapon:WaitForChild("Handle"), AttTable.SightAtt.Main)
		AttTable.SightAtt:SetPrimaryPartCFrame(weapon.Nodes.Sight.CFrame)
		weapon.AimPart.CFrame = AttTable.SightAtt.AimPos.CFrame
		
		--print(weapon.Name.." "..WeaponData.SightAtt)
		

	end

	--load Muzzle Att
	if weapon.Nodes:FindFirstChild("Muzzle") ~= nil and WeaponData.MuzzleAtt ~= "" then



		AttTable.MuzzleAtt = AttModels[WeaponData.MuzzleAtt]:Clone()
		AttTable.MuzzleAtt.Parent = weapon
		for index, key in pairs(AttTable.MuzzleAtt:GetChildren()) do
			if not key:IsA('BasePart') or key.Name == "Main" then 
				continue; 
			end;
			Ultil.Weld(AttTable.MuzzleAtt.Main, key )
			key.Anchored = false
			key.CanCollide = false
		end

		Ultil.Weld(weapon:WaitForChild("Handle"), AttTable.MuzzleAtt.Main)
		AttTable.MuzzleAtt:SetPrimaryPartCFrame(weapon.Nodes.Muzzle.CFrame)

		if WeaponData.Archetype == "Double Barrel" then
			local MuzzleAtt2 = AttModels[WeaponData.MuzzleAtt]:Clone()
			MuzzleAtt2.Parent = weapon
			for index, key in pairs(MuzzleAtt2:GetChildren()) do
				if not key:IsA('BasePart') then 
					continue; 
				end;
				Ultil.Weld(weapon:WaitForChild("Handle"), key )
				key.Anchored = false
				key.CanCollide = false
			end
			MuzzleAtt2:SetPrimaryPartCFrame(weapon.Nodes.Muzzle2.CFrame)
		end

		if AttTable.MuzzleAtt:FindFirstChild("BarrelPos") ~= nil then
			weapon.Handle.Muzzle.WorldCFrame = AttTable.MuzzleAtt.BarrelPos.CFrame
		end

		for index, key in pairs(weapon:GetDescendants()) do
			if key.Name == "Muzzle" and key:IsA("BasePart") then 
				key.Transparency = 1
			end;
			if key.Name == "US" and key:IsA("BasePart") then 
				key.Transparency = 0
			end;
		end

	end

	--load Under Barrel Att
	if weapon.Nodes:FindFirstChild("UnderBarrel") ~= nil and WeaponData.UnderBarrelAtt ~= "" then

		local UnderBarrelData =  require(AttModules.UnderBarrel[WeaponData.UnderBarrelAtt])
		
		for index, key in pairs(weapon:GetDescendants()) do
			if key.Name == "GR" or key.Name == "UB" then 
				key.Transparency = 0
			elseif key.Name == "RG" or key.Name == "BU" then
				key.Transparency = 1
			end;
		end

		if not UnderBarrelData.IsGrenadeLauncher and not UnderBarrelData.IsBipod then
			AttTable.UnderBarrelAtt = AttModels[WeaponData.UnderBarrelAtt]:Clone()
			AttTable.UnderBarrelAtt.Parent = weapon


			for index, key in pairs(AttTable.UnderBarrelAtt:GetChildren()) do
				if not key:IsA('BasePart') or key.Name == "Main" then 
					continue; 
				end;
				Ultil.Weld(AttTable.UnderBarrelAtt.Main, key )
				key.Anchored = false
				key.CanCollide = false
			end

			Ultil.Weld(weapon:WaitForChild("Handle"), AttTable.UnderBarrelAtt.Main)
			AttTable.UnderBarrelAtt:SetPrimaryPartCFrame(weapon.Nodes.UnderBarrel.CFrame)

		elseif UnderBarrelData.IsBipod then
			local BipodModel = weapon:FindFirstChild("Bipod")

			if BipodModel then
				-- Hide all magazine models first
				for _, bipod in pairs(weapon.Bipod:GetChildren()) do
					if bipod:IsA("Model") then
						for _, part in pairs(bipod:GetDescendants()) do
							if part:IsA("BasePart") then
								part.Transparency = 1
								part.CanCollide = false

							end
						end
					end
				end

				-- Move selected magazine to weapon and make visible
				for _, part in pairs(BipodModel:GetDescendants()) do
					if part:IsA("BasePart") then
						part.Parent = weapon
						if part:IsA("MeshPart") then
							part.Transparency = 0
						end
					end
				end
			end
		end
	end

	if weapon.Nodes:FindFirstChild("Other") ~= nil and WeaponData.OtherAtt ~= "" then

		AttTable.OtherAtt = AttModels[WeaponData.OtherAtt]:Clone()
		AttTable.OtherAtt.Parent = weapon

		for index, key in pairs(weapon:GetDescendants()) do
			if key.Name == "GR" or key.Name == "OT" then 
				key.Transparency = 0
			elseif key.Name == "RG" or key.Name == "TO" then
				key.Transparency = 1
			end;
		end
		
		for index, key in pairs(AttTable.OtherAtt:GetChildren()) do
			if not key:IsA('BasePart') or key.Name == "Main" then 
				continue; 
			end;
			Ultil.Weld(AttTable.OtherAtt.Main, key )
			key.Anchored = false
			key.CanCollide = false
		end
		
		Ultil.Weld(weapon:WaitForChild("Handle"), AttTable.OtherAtt.Main)
		
		AttTable.OtherAtt:SetPrimaryPartCFrame(weapon.Nodes.Other.CFrame)
	end

	-- Load Magazine Attachment
	if weapon:FindFirstChild("Mags") then
		local magName = (WeaponData.MagAtt ~= "" and WeaponData.MagAtt) or "Standard Mag"
		local selectedMag = weapon.Mags:FindFirstChild(magName)

		if selectedMag then
			-- Hide all magazine models first
			for _, mag in pairs(weapon.Mags:GetChildren()) do
				if mag:IsA("Model") then
					for _, part in pairs(mag:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Transparency = 1
							part.CanCollide = false
						end
					end
				end
			end

			-- Move selected magazine to weapon and make visible
			for _, part in pairs(selectedMag:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
					part.Parent = weapon
				end
			end
		end
	end

	-- Load Stock Attachment
	if weapon:FindFirstChild("Stocks") then
		local stockName = (WeaponData.StockAtt ~= "" and WeaponData.StockAtt) or "Standard Stock"
		local selectedStock = weapon.Stocks:FindFirstChild(stockName)

		if selectedStock then
			-- Hide all stock models first
			for _, stock in pairs(weapon.Stocks:GetChildren()) do
				if stock:IsA("Model") then
					for _, part in pairs(stock:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Transparency = 1
							part.CanCollide = false
						end
					end
				end
			end

			-- Move selected stock to weapon and make visible
			for _, part in pairs(selectedStock:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Transparency = 0
					part.Parent = weapon
				end
			end
		end
	end

	if WeaponData.AmmoAtt == "" then 
		WeaponData.AmmoAtt = "Default"
	end
	if WeaponData.AmmoAtt ~= "" then

	end
end

Evt.Equip.OnServerEvent:Connect(function(Player,Arma,Mode,Settings,Anim)
	if Player.Character then
		--StreakUpdate(Player)
		if Mode == 1 then
			local Head = Player.Character:FindFirstChild('Head')
			local UpperTorso = Player.Character:FindFirstChild('UpperTorso')
			local LowerTorso = Player.Character:FindFirstChild('LowerTorso')

			local ServerGun = GunModels:FindFirstChild(Arma.Name):Clone()
			ServerGun.Name = 'S' .. Arma.Name

			
			
			
			AnimBase = Instance.new("Part", Player.Character)
			--AnimBase.FormFactor = "Custom"
			AnimBase.CanCollide = false
			AnimBase.Transparency = 1
			AnimBase.Anchored = false
			AnimBase.Name = "AnimBase"
			AnimBase.Size = Vector3.new(0.1, 0.1, 0.1)

			AnimBaseW = Instance.new("Motor6D")
			AnimBaseW.Part0 = Head
			AnimBaseW.Part1 = AnimBase
			AnimBaseW.Parent = AnimBase
			AnimBaseW.Name = "AnimBaseW"
			--AnimBaseW.C0 = CFrame.new(0,-1.25,0)

			-- TORSO TILT SETUP
			-- Store the original waist joint
			local Waist = UpperTorso:FindFirstChild("Waist")
			if Waist then
				-- Store original C0 and C1 for restoration later
				local OriginalWaistC0 = Waist.C0
				local OriginalWaistC1 = Waist.C1

				-- Apply tilt to the upper torso
				-- Adjust these angles to control the tilt amount
				local tiltAngle = math.rad(-45) -- 15 degrees tilt (adjust as needed)
				local leanForward = math.rad(0) -- Slight forward lean (optional)

				-- Create the tilt CFrame (Y rotation for left/right tilt, X for forward/back lean)
				local tiltCFrame = CFrame.Angles(leanForward, tiltAngle, 0)

				-- Apply the tilt to the waist joint
				Waist.C0 = OriginalWaistC0 * tiltCFrame

				-- Store these values for restoration in Mode 2
				Waist:SetAttribute("OriginalC0X", OriginalWaistC0.X)
				Waist:SetAttribute("OriginalC0Y", OriginalWaistC0.Y)
				Waist:SetAttribute("OriginalC0Z", OriginalWaistC0.Z)
			end

			RA = Player.Character['RightUpperArm']
			LA = Player.Character['LeftUpperArm']
			RightS = RA:WaitForChild("RightShoulder")
			LeftS = LA:WaitForChild("LeftShoulder")

			-- RIGHT ARM SETUP (with compensation for torso tilt)
			ruaw = Instance.new("Motor6D")
			ruaw.Name = "RAW"
			ruaw.Part0 = RA
			ruaw.Part1 = AnimBase
			ruaw.Parent = AnimBase

			-- Compensate for torso rotation to keep arm pointing forward
			-- This counter-rotates the arm relative to the torso tilt
			local compensationAngle = math.rad(-45) -- Negative of torso tilt angle
			local armCompensation = CFrame.Angles(0, compensationAngle, 0)
			ruaw.C0 = armCompensation * Anim.SV_RightArmPos

			RightS.Enabled = false

			rlaw = Instance.new("Motor6D")
			rlaw.Name = "RLAW"
			rlaw.Part0 = Player.Character.RightLowerArm
			rlaw.Part1 = RA
			rlaw.Parent = AnimBase
			rlaw.C0 = CFrame.new(0,RA.Size.Y/2,0) * Anim.SV_RightElbowPos

			ruaw = Instance.new("Motor6D")
			ruaw.Name = "RHW"
			ruaw.Part0 = Player.Character.RightHand
			ruaw.Part1 = Player.Character.RightLowerArm
			ruaw.Parent = AnimBase
			ruaw.C0 = CFrame.new(0,Player.Character.RightLowerArm.Size.Y/2,0) * Anim.SV_RightWristPos

			-- LEFT ARM IK SETUP
			-- The IK control will automatically handle the left arm positioning
			-- The tilt will naturally make the left arm reach more forward
			local LeftIKCont = Instance.new("IKControl",Player.Character.Humanoid)
			LeftIKCont.Name = "LeftIKControl"
			LeftIKCont.EndEffector = Player.Character.LeftHand
			LeftIKCont.ChainRoot = Player.Character.LeftUpperArm
			LeftIKCont.Target = ServerGun.Handle.LeftGrip
			LeftIKCont.Pole = ServerGun.Handle.LeftDir
			LeftIKCont.Weight = 1
			LeftIKCont.SmoothTime = 0.02

			-- Optional: Add slight compensation to left shoulder if needed
			-- This can help maintain better arm alignment
			if LeftS then
				local leftCompensation = CFrame.Angles(0, math.rad(-7), 0) -- Slight compensation
				LeftS.C0 = LeftS.C0 * leftCompensation
				LeftS:SetAttribute("CompensationApplied", true)
			end

			ServerGun.Parent = Player.Character
			loadAttachment(ServerGun,Settings,Arma,Player)


			for SKP_001, SKP_002 in pairs(ServerGun:GetDescendants()) do
				if SKP_002.Name == "SightMark" or SKP_002.Name == "SightMark2" then
					SKP_002:Destroy()
				end
			end

			for SKP_001, SKP_002 in pairs(ServerGun:GetDescendants()) do
				if SKP_002:IsA('BasePart') and SKP_002.Name ~= 'Handle' then
					Ultil.WeldComplex(ServerGun:WaitForChild("Handle"), SKP_002, SKP_002.Name)
				end;
			end
			
			
			
			
			local SKP_004 = Instance.new('Motor6D')
			SKP_004.Name = 'Handle'
			SKP_004.Parent = ServerGun.Handle
			SKP_004.Part0 = Player.Character['RightHand']
			SKP_004.Part1 = ServerGun.Handle
			SKP_004.C1 = Anim.SV_GunPos:inverse()

			for L_74_forvar1, L_75_forvar2 in pairs(ServerGun:GetDescendants()) do
				if L_75_forvar2:IsA('BasePart') then
					L_75_forvar2.Anchored = false
					L_75_forvar2.CanCollide = false
				end
			end

		elseif Mode == 2 then
			-- CLEANUP AND RESTORATION
			if Arma and Player.Character:FindFirstChild('S' .. Arma.Name) ~= nil then
				Player.Character['S' .. Arma.Name]:Destroy()
				Player.Character.AnimBase:Destroy()
			end

			-- Restore torso to original position
			local UpperTorso = Player.Character:FindFirstChild('UpperTorso')
			if UpperTorso then
				local Waist = UpperTorso:FindFirstChild("Waist")
				if Waist then
					-- Check if we have stored original values
					local origX = Waist:GetAttribute("OriginalC0X")
					local origY = Waist:GetAttribute("OriginalC0Y")
					local origZ = Waist:GetAttribute("OriginalC0Z")

					if origX and origY and origZ then
						-- Restore original C0
						Waist.C0 = CFrame.new(origX, origY, origZ)

						-- Clean up attributes
						Waist:SetAttribute("OriginalC0X", nil)
						Waist:SetAttribute("OriginalC0Y", nil)
						Waist:SetAttribute("OriginalC0Z", nil)
					else
						-- Fallback: reset to default if no stored values
						Waist.C0 = CFrame.new(0, 0.2, 0)
					end
				end
			end

			-- Restore shoulders
			if Player.Character:FindFirstChild("RightUpperArm") and Player.Character.RightUpperArm:FindFirstChild("RightShoulder") then
				Player.Character.RightUpperArm:WaitForChild("RightShoulder").Enabled = true
			end

			if Player.Character:FindFirstChild("LeftUpperArm") and Player.Character.LeftUpperArm:FindFirstChild("LeftShoulder") then
				local LeftS = Player.Character.LeftUpperArm:WaitForChild("LeftShoulder")
				LeftS.Enabled = true

				-- Reset any compensation we applied
				if LeftS:GetAttribute("CompensationApplied") then
					LeftS.C0 = CFrame.new(-0.5, 0.5, 0) -- Default left shoulder C0
					LeftS:SetAttribute("CompensationApplied", nil)
				end
			end

			-- Clean up IK controls
			local humanoid = Player.Character:FindFirstChild("Humanoid")
			if humanoid then
				local leftIK = humanoid:FindFirstChild("LeftIKControl")
				if leftIK then
					leftIK:Destroy()
				end
			end
		end
	end
end)

Evt.Squad.OnServerEvent:Connect(function(Player,SquadName,SquadColor)
	if Player.Character:FindFirstChild("Client") then
		Player.Character.Client.FireTeam.SquadName.Value = SquadName
		Player.Character.Client.FireTeam.SquadColor.Value = SquadColor
	end
end)

Evt.HeadRot.OnServerEvent:connect(function(Player, CF)
	Evt.HeadRot:FireAllClients(Player, CF)
end)

Evt.Atirar.OnServerEvent:Connect(function(Player, Arma, Suppressor, FlashHider, Pos)
	Evt.Atirar:FireAllClients(Player, Arma, Suppressor, FlashHider, Pos)
end)

Evt.Whizz.OnServerEvent:Connect(function(Player, Victim)
	Evt.Whizz:FireClient(Victim)
end)

Evt.Suppression.OnServerEvent:Connect(function(Player,Victim,Mode,Intensity,Time)
	PlayCharacterSound(Victim.Character,"Suppressed")
	Evt.Suppression:FireClient(Victim,Mode,Intensity,Time)
end)

Evt.Refil.OnServerEvent:Connect(function(Player, Stored, NewStored)
	Stored.Value = Stored.Value - NewStored
end)

Evt.SVLaser.OnServerEvent:Connect(function(Player,Position,Modo,Cor,IRmode,Arma)
	Evt.SVLaser:FireAllClients(Player,Position,Modo,Cor,IRmode,Arma)
end)

Evt.SVFlash.OnServerEvent:Connect(function(Player,Arma,Mode)
	Evt.SVFlash:FireAllClients(Player,Arma,Mode)
end)

----------------------------------------------------------------
--\\DOORS & BREACHING SYSTEM
----------------------------------------------------------------
local ServerStorage = game:GetService("ServerStorage")
local DoorsFolder = Game_Workspace:FindFirstChild("Doors")
local DoorsFolderClone = DoorsFolder:Clone()
local BreachClone = Game_Workspace.Breach:Clone()
BreachClone.Parent = ServerStorage
DoorsFolderClone.Parent = ServerStorage

function ToggleDoor(Door)
	local Hinge = Door:FindFirstChild("Hinge")
	if not Hinge then return end
	local HingeConstraint = Hinge.HingeConstraint
	if HingeConstraint.TargetAngle == 0 then
		HingeConstraint.TargetAngle = -90
	elseif HingeConstraint.TargetAngle == -90 then
		HingeConstraint.TargetAngle = 0
	end	
end

function OpenDoor(Door)
	local Hinge = Door:FindFirstChild("Hinge")
	if not Hinge then return end
	local HingeConstraint = Hinge.HingeConstraint
	if HingeConstraint.TargetAngle == 0 then
		HingeConstraint.TargetAngle = -90
	end	
end

-- New function to open door away from player
function OpenDoorAwayFromPlayer(Door, PlayerPosition)
	local Hinge = Door:FindFirstChild("Hinge")
	if not Hinge then 
		print("No Hinge found in door")
		return 
	end

	local HingeConstraint = Hinge.HingeConstraint
	if HingeConstraint.TargetAngle ~= 0 then return end -- Door is already open

	-- Get the door's position and orientation
	local DoorPart = Door:FindFirstChild("Door")
	if not DoorPart then 
		print("No Door part found")
		return 
	end

	-- Try using the hinge position instead of door position for more accuracy
	local HingePosition = Hinge.Position
	local DoorToPlayer = (PlayerPosition - HingePosition).Unit

	-- Get the hinge's look vector (the direction the hinge is facing)
	local HingeCFrame = Hinge.CFrame
	local HingeLookVector = HingeCFrame.LookVector

	-- Use cross product to determine which side the player is on
	local CrossProduct = HingeLookVector:Cross(DoorToPlayer)
	local DotProduct = CrossProduct.Y -- Y component tells us the rotation direction

	-- Debug prints
	print("Player Position:", PlayerPosition)
	print("Hinge Position:", HingePosition)
	print("Door to Player:", DoorToPlayer)
	print("Hinge Look Vector:", HingeLookVector)
	print("Dot Product (Y):", DotProduct)

	-- Open the door away from the player
	if DotProduct > 0 then
		print("Opening door to 90 degrees")
		HingeConstraint.TargetAngle = 90
	else
		print("Opening door to -90 degrees")
		HingeConstraint.TargetAngle = -90
	end
end

Evt.DoorEvent.OnServerEvent:Connect(function(Player, Door, Mode, Key)
	if Door ~= nil then
		if Mode == 1 then
			if Door:FindFirstChild("Locked") ~= nil and Door.Locked.Value == true then
				if Door:FindFirstChild("RequiresKey") then
					local Character = Player.Character
					if Character:FindFirstChild(Key) ~= nil or Player.Backpack:FindFirstChild(Key) ~= nil then
						if Door.Locked.Value == true then
							Door.Locked.Value = false
						end
						ToggleDoor(Door)
					end	
				end
			else
				ToggleDoor(Door)
			end
		elseif Mode == 2 then
			if Door:FindFirstChild("Locked") == nil or (Door:FindFirstChild("Locked") ~= nil and Door.Locked.Value == false) then
				ToggleDoor(Door)
			end
		elseif Mode == 3 then
			if Door:FindFirstChild("RequiresKey") then
				local Character = Player.Character
				Key = Door.RequiresKey.Value
				if Character:FindFirstChild(Key) ~= nil or Player.Backpack:FindFirstChild(Key) ~= nil then
					if Door:FindFirstChild("Locked") ~= nil and Door.Locked.Value == true then
						Door.Locked.Value = false
					else
						Door.Locked.Value = true
					end
				end
			end
		elseif Mode == 4 then
			if Door:FindFirstChild("Locked") ~= nil and Door.Locked.Value == true then
				Door.Locked.Value = false
			end
		elseif Mode == 5 then
			-- Modified to open door away from player
			local Character = Player.Character
			if Character and Character:FindFirstChild("UpperTorso") then
				OpenDoorAwayFromPlayer(Door, Character.UpperTorso.Position)
			else
				-- Fallback to original behavior if no character/torso found
				OpenDoor(Door)
			end
		end
	end
end)

Evt.MedSys.Collapse.OnServerEvent:Connect(function(Player)

	local Human = Player.Character.Humanoid
	local PClient = Human.Parent.Client
	local Dor = Human.Parent.Client.Variaveis.Dor
	local Sangue = Human.Parent.Client.Variaveis.Sangue

	if (Sangue.Value <= 3500) or (Dor.Value >= 200) or PClient:GetAttribute("Collapsed") then -- Man this Guy's Really wounded,
		Human.PlatformStand = true
		Human.AutoRotate = false	
		PClient:SetAttribute("Collapsed",true)
	elseif (Sangue.Value > 3500) and (Dor.Value < 200) and not PClient:GetAttribute("Collapsed")  then -- YAY A MEDIC ARRIVED! =D
		Human.PlatformStand = false
		Human.AutoRotate = true	
		PClient:SetAttribute("Collapsed",false)
	end
end)

Evt.MedSys.MedHandler.OnServerEvent:Connect(function(Player, Victim, Mode)
	if Player and Player.Character and Player.Character.Humanoid.Health > 0 then

		local P1_Client = Player.Character:FindFirstChild("Client")

		if P1_Client == nil then
			warn(Player.Name.."'s Action Failed: Missing Client")
			return
		end

		if P1_Client:GetAttribute("Collapsed") then
			return
		end

		if Victim then --Multiplayer functions
			if Player.Character and Victim.Character and (Player.Character.HumanoidRootPart.Position - Victim.Character.HumanoidRootPart.Position).Magnitude <= 15 then

				local P2_Client = Victim.Character:FindFirstChild("Client")

				if P2_Client == nil then
					warn(Player.Name.."'s Action Failed: Missing "..Victim.Name.."'s Client")
					return
				end

				if Mode == 1 and P1_Client.Kit.Bandage.Value > 0 and P2_Client:GetAttribute("Bleeding") then
					P1_Client.Kit.Bandage.Value = P1_Client.Kit.Bandage.Value - 1
					P2_Client:SetAttribute("Bleeding",false)

				elseif Mode == 2 and P1_Client.Kit.Splint.Value > 0 and P2_Client:GetAttribute("Injured") then
					P1_Client.Kit.Splint.Value = P1_Client.Kit.Splint.Value - 1
					P2_Client:SetAttribute("Injured",false)

				elseif Mode == 3 and (P2_Client:GetAttribute("Bleeding") == true or P2_Client:GetAttribute("Tourniquet")) then --Tourniquet works a little different :T
					if P2_Client:GetAttribute("Tourniquet")then
						P1_Client.Kit.Tourniquet.Value = P1_Client.Kit.Tourniquet.Value + 1
						P2_Client:SetAttribute("Tourniquet",false)
					else
						if P1_Client.Kit.Tourniquet.Value > 0 then
							P1_Client.Kit.Tourniquet.Value = P1_Client.Kit.Tourniquet.Value - 1
							P2_Client:SetAttribute("Tourniquet",true)
						end
					end

				elseif Mode == 4 and P1_Client.Kit.PainKiller.Value > 0 and P2_Client.Variaveis.Dor.Value > 0 then
					P1_Client.Kit.PainKiller.Value = P1_Client.Kit.PainKiller.Value - 1
					P2_Client.Variaveis.Dor.Value = math.clamp(P2_Client.Variaveis.Dor.Value - math.random(35,65),0,300)
					Evt.MedSys.MedHandler:FireClient(Victim,4)

				elseif Mode == 5 and P1_Client.Kit.EnergyShot.Value > 0 and Victim.Character.Humanoid.Health < Victim.Character.Humanoid.MaxHealth then
					P1_Client.Kit.EnergyShot.Value = P1_Client.Kit.EnergyShot.Value - 1
					local HealValue = math.random(15,25)
					if Victim.Character.Humanoid.Health + HealValue < Victim.Character.Humanoid.MaxHealth then
						Victim.Character.Humanoid:TakeDamage(-HealValue)
					else
						Victim.Character.Humanoid.Health = Victim.Character.Humanoid.MaxHealth
					end
					Evt.MedSys.MedHandler:FireClient(Victim,5)

				elseif Mode == 6 and P1_Client.Kit.Morphine.Value > 0 and P2_Client.Variaveis.Dor.Value > 0 then
					P1_Client.Kit.Morphine.Value = P1_Client.Kit.Morphine.Value - 1
					P2_Client.Variaveis.Dor.Value = 0
					Evt.MedSys.MedHandler:FireClient(Victim,6)

				elseif Mode == 7 and P1_Client.Kit.Epinephrine.Value > 0 and P2_Client:GetAttribute("Collapsed")then
					P1_Client.Kit.Epinephrine.Value = P1_Client.Kit.Epinephrine.Value - 1
					local HealValue = math.random(45,55)
					if Victim.Character.Humanoid.Health + HealValue < Victim.Character.Humanoid.MaxHealth then
						Victim.Character.Humanoid:TakeDamage(-HealValue)
					else
						Victim.Character.Humanoid.Health = Victim.Character.Humanoid.MaxHealth
					end
					P2_Client:SetAttribute("Collapsed",false)
					Evt.MedSys.MedHandler:FireClient(Victim,7)

				elseif Mode == 8 and P1_Client.Kit.BloodBag.Value > 0 and P2_Client.Variaveis.Sangue.Value < P2_Client.Variaveis.Sangue.MaxValue then
					P1_Client.Kit.BloodBag.Value = P1_Client.Kit.BloodBag.Value - 1
					P2_Client.Variaveis.Sangue.Value = P2_Client.Variaveis.Sangue.Value + 2000
				end
			else
				warn(Player.Name.." is too far to treat "..Victim.Name)
			end
		else --Self treat
			if Mode == 1 and P1_Client.Kit.Bandage.Value > 0 and P1_Client:GetAttribute("Bleeding") then
				P1_Client.Kit.Bandage.Value = P1_Client.Kit.Bandage.Value - 1
				P1_Client:SetAttribute("Bleeding",false)

			elseif Mode == 2 and P1_Client.Kit.Splint.Value > 0 and P1_Client:GetAttribute("Injured") then
				P1_Client.Kit.Splint.Value = P1_Client.Kit.Splint.Value - 1
				P1_Client:SetAttribute("Injured",false)

			elseif Mode == 3 and (P1_Client:GetAttribute("Bleeding") or P1_Client:GetAttribute("Tourniquet")) then --Tourniquet works a little diferent :T
				if P1_Client:GetAttribute("Tourniquet") then
					P1_Client.Kit.Tourniquet.Value = P1_Client.Kit.Tourniquet.Value + 1
					P1_Client:SetAttribute("Tourniquet",false)
				else
					if P1_Client.Kit.Tourniquet.Value > 0 then
						P1_Client.Kit.Tourniquet.Value = P1_Client.Kit.Tourniquet.Value - 1
						P1_Client:SetAttribute("Tourniquet",true)
					end
				end

			elseif Mode == 4 and P1_Client.Kit.PainKiller.Value > 0 and P1_Client.Variaveis.Dor.Value > 0 then
				P1_Client.Kit.PainKiller.Value = P1_Client.Kit.PainKiller.Value - 1
				P1_Client.Variaveis.Dor.Value = math.clamp(P1_Client.Variaveis.Dor.Value - math.random(35,65),0,300)
				Evt.MedSys.MedHandler:FireClient(Player,4)

			elseif Mode == 5 and P1_Client.Kit.EnergyShot.Value > 0 and Player.Character.Humanoid.Health < Player.Character.Humanoid.MaxHealth then
				P1_Client.Kit.EnergyShot.Value = P1_Client.Kit.EnergyShot.Value - 1
				local HealValue = math.random(15,25)
				if Player.Character.Humanoid.Health + HealValue < Player.Character.Humanoid.MaxHealth then
					Player.Character.Humanoid:TakeDamage(-HealValue)
				else
					Player.Character.Humanoid.Health = Player.Character.Humanoid.MaxHealth
				end
				Evt.MedSys.MedHandler:FireClient(Player,5)

			elseif Mode == 6 and P1_Client.Kit.Morphine.Value > 0 and P1_Client.Variaveis.Dor.Value > 0 then
				P1_Client.Kit.Morphine.Value = P1_Client.Kit.Morphine.Value - 1
				P1_Client.Variaveis.Dor.Value = math.clamp(P1_Client.Variaveis.Dor.Value - math.random(125,175),0,300)
				Evt.MedSys.MedHandler:FireClient(Player,6)

			elseif Mode == 7 and P1_Client.Kit.Epinephrine.Value > 0 and Player.Character.Humanoid.Health < Player.Character.Humanoid.MaxHealth then
				P1_Client.Kit.Epinephrine.Value = P1_Client.Kit.Epinephrine.Value - 1
				local HealValue = math.random(45,55)
				if Player.Character.Humanoid.Health + HealValue < Player.Character.Humanoid.MaxHealth then
					Player.Character.Humanoid:TakeDamage(-HealValue)
				else
					Player.Character.Humanoid.Health = Player.Character.Humanoid.MaxHealth
				end
				Evt.MedSys.MedHandler:FireClient(Player,7)

			elseif Mode == 8 and P1_Client.Kit.BloodBag.Value > 0 and P1_Client.Variaveis.Sangue.Value < P1_Client.Variaveis.Sangue.MaxValue then
				P1_Client.Kit.BloodBag.Value = P1_Client.Kit.BloodBag.Value - 1
				P1_Client.Variaveis.Sangue.Value = P1_Client.Variaveis.Sangue.Value + 2000

			end
		end
	end
end)
Evt.CruiseMissile.OnServerEvent:Connect(function(plr)
	local Char = plr.Character
	local Human = Char:FindFirstChild("Humanoid")
	local HumanoidRootPart = Char:FindFirstChild("HumanoidRootPart")
	local Cam = workspace.CurrentCamera

	local MissilePos = HumanoidRootPart.Position + Vector3.new(0,200,0)
	local Missile = Instance.new("Part",Game_Workspace.Missiles)
	Missile.Position = MissilePos
	Missile.Size = Vector3.new(4,4,12)
	Missile.Orientation = Vector3.new(-90,0,0)
	Missile.Name = "Missile_"..plr.UserId
	Evt.CruiseMissile:FireClient(plr,Missile)
end)
Evt.SetupMuzzle.OnServerEvent:Connect(function(plr,Config,muzzle)
	if plr.Character then
		if plr.Character:FindFirstChild("S"..Config.gunName) then 
			if Engine.FX:FindFirstChild(Config.MuzzleFlash) then
				local WeaponInHand = plr.Character:FindFirstChild("S"..Config.gunName)
				for i,v in pairs(Engine.FX[Config.MuzzleFlash]:GetChildren()) do
					local vC = v:Clone()
					if muzzle == "Muzzle" then
						vC.Parent = WeaponInHand.Handle.Muzzle
					else
						vC.Parent = WeaponInHand.Handle.GrenadeMuzzle
					end
				end
			end
		end
	end
end)
Evt.Drag.OnServerEvent:Connect(function(player,Victim)

	local P1_Client = player.Character:FindFirstChild("Client")
	local Human 	= player.Character.Humanoid

	if not P1_Client then
		return
	end

	if Victim then
		P1_Client:SetAttribute("DragPlayer",Victim.Name)
	else
		P1_Client:SetAttribute("DragPlayer","")
		P1_Client:SetAttribute("Dragging",false)
	end

	local target = P1_Client:GetAttribute("DragPlayer")

	if not P1_Client:GetAttribute("Collapsed") and target ~= "" then

		local player2 = game.Players:FindFirstChild(target)
		local PlHuman = player2.Character.Humanoid
		local P2_Client = player2.Character:FindFirstChild("Client")
		if not P2_Client then
			return
		end
		if not P1_Client:GetAttribute("Dragging") then
			if P2_Client:GetAttribute("Collapsed") then 
				P1_Client:SetAttribute("Dragging",true)	
				while P1_Client:GetAttribute("Dragging") and target ~= "" and P2_Client:GetAttribute("Collapsed") and PlHuman.Health > 0 and Human.Health > 0 and not P1_Client:GetAttribute("Collapsed") do wait() 
					player2.Character.UpperTorso.Anchored = true
					player2.Character.UpperTorso.CFrame = Human.Parent.UpperTorso.CFrame*CFrame.new(0,0.75,1.5)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(90))
				end
				player2.Character.UpperTorso.Anchored = false
			end	
		end	
	end
end)

function BreachFunction(Player,Mode,BreachPlace,Pos,Norm,Hit)

	if Mode == 1 then
		if Player.Character.Client.Kit.BreachCharges.Value > 0 then
			Player.Character.Client.Kit.BreachCharges.Value = Player.Character.Client.Kit.BreachCharges.Value - 1
			BreachPlace.Destroyed.Value = true
			local C4 = Engine.FX.BreachCharge:Clone()

			C4.Parent = BreachPlace.Destroyable
			C4.Center.CFrame = CFrame.new(Pos, Pos + Norm) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))
			C4.Center.Place:Play()

			local weld = Instance.new("WeldConstraint")
			weld.Parent = C4
			weld.Part0 = BreachPlace.Destroyable.Charge
			weld.Part1 = C4.Center

			wait(1)
			C4.Center.Beep:Play()
			wait(4)
			if C4 and C4:FindFirstChild("Center") then
				local att = Instance.new("Attachment")
				att.CFrame = C4.Center.CFrame
				att.Parent = workspace.Terrain

				local aw = Engine.FX.ExpEffect:Clone()
				aw.Parent = att
				aw.Enabled = false
				aw:Emit(35)
				Debris:AddItem(aw,aw.Lifetime.Max)

				local Exp = Instance.new("Explosion")
				Exp.BlastPressure = 0
				Exp.BlastRadius = 0
				Exp.DestroyJointRadiusPercent = 0
				Exp.Position = C4.Center.Position
				Exp.Parent = workspace

				local S = Instance.new("Sound")
				S.RollOffMinDistance = 10
				S.RollOffMaxDistance = 1000
				S.SoundId = "rbxassetid://"..Explosion[math.random(1, 7)]
				S.PlaybackSpeed = math.random(30,55)/40
				S.Volume = 2
				S.Parent = att
				S.PlayOnRemove = true
				S:Destroy()

				for SKP_001, SKP_002 in pairs(game.Players:GetChildren()) do
					if SKP_002:IsA('Player') and SKP_002.Character and SKP_002.Character:FindFirstChild('Head') and (SKP_002.Character.Head.Position - C4.Center.Position).magnitude <= 15 then
						local DistanceMultiplier = (((SKP_002.Character.Head.Position - C4.Center.Position).magnitude/35) - 1) * -1
						local intensidade = DistanceMultiplier
						local Tempo = 15 * DistanceMultiplier
						Evt.Suppression:FireClient(SKP_002,2,intensidade,Tempo)
					end
				end

				Debris:AddItem(BreachPlace.Destroyable,0)
			end
		end

	elseif Mode == 2 then

		local aw = Engine.FX.DoorBreachFX:Clone()
		aw.Parent = BreachPlace.Door.Door
		aw.RollOffMaxDistance = 100
		aw.RollOffMinDistance = 5
		aw:Play()

		BreachPlace.Destroyed.Value = true
		if BreachPlace.Door:FindFirstChild("Hinge") ~= nil then
			BreachPlace.Door.Hinge:Destroy()
		end
		if BreachPlace.Door:FindFirstChild("Knob") ~= nil then
			BreachPlace.Door.Knob:Destroy()
		end

		local forca = Instance.new("BodyForce")
		forca.Force = -Norm * BreachPlace.Door.Door:GetMass() * Vector3.new(50,0,50)
		forca.Parent = BreachPlace.Door.Door

		Debris:AddItem(BreachPlace,3)

	elseif Mode == 3 then
		if Player.Character.Client.Kit.Fortifications.Value > 0 then
			Player.Character.Client.Kit.Fortifications.Value = Player.Character.Client.Kit.Fortifications.Value - 1
			BreachPlace.Fortified.Value = true
			local C4 = Instance.new('Part')

			C4.Parent = BreachPlace.Destroyable
			C4.Size =  Vector3.new(Hit.Size.X + .05,Hit.Size.Y + .05,Hit.Size.Z + 0.5) 
			C4.Material = Enum.Material.DiamondPlate
			C4.Anchored = true
			C4.CFrame = Hit.CFrame

			local S = Engine.FX.FortFX:Clone()
			S.PlaybackSpeed = math.random(30,55)/40
			S.Volume = 1
			S.Parent = C4
			S.PlayOnRemove = true
			S:Destroy()
		end
	end
end

Evt.Breach.OnServerInvoke = BreachFunction

function UpdateLog(Player,humanoid)

	local tag = humanoid:findFirstChild("creator")

	if tag ~= nil then

		local hours = os.date("*t")["hour"]
		local mins = os.date("*t")["min"]
		local sec = os.date("*t")["sec"]
		local TagType = tag:findFirstChild("type")

		if tag.Value.Name == Player.Name then
			local String = Player.Name.." Died | "..hours..":"..mins..":"..sec
			table.insert(CombatLog,String)
		else
			local String = tag.Value.Name.." Killed "..Player.Name.." | "..hours..":"..mins..":"..sec
			table.insert(CombatLog,String)
		end

		if #CombatLog > 50 then
			Backup = Backup + 1
			warn("Game: Cleaning Combat Log | Backup: "..Backup)
			warn(CombatLog)
			CombatLog = {}
		end
	end
end

-- Check if the player can run commands
function CheckHostID(player)

	-- Is the game running in studio
	if Run:IsStudio() then return true end


	if game.CreatorType == Enum.CreatorType.User then
		-- Is the player the game's owner
		if player.UserId == game.CreatorId then return true end
	elseif game.CreatorType == Enum.CreatorType.Group then
		-- Does the player have a high enough group rank
		if player:GetRankInGroup(game.CreatorId) >= gameRules.HostRank then return true end
	end

	-- Is the player in the game host list
	for _, cID in pairs(gameRules.HostList) do
		if player.UserId == cID then return true end
	end
	return false
end

-- Reset broken glass
function ResetGlass()
	for i, gData in pairs(dParts.Glass) do
		gData[1].Parent = gData[2]

		for _, shard in pairs(gData[3]) do
			if shard then shard:Destroy() end
		end

		dParts.Glass[i] = nil
	end
end

-- Reset broken lights
function ResetLights()
	for i, lData in pairs(dParts.Lights) do
		lData[1].Material = lData[2]
		lData[1].Broken:Destroy()

		for _, light in pairs(lData[1]:GetChildren()) do
			if light:IsA("Light") then
				light.Enabled = true
			end
		end
	end
end

-- Clear dropped weapons
function ClearDroppedGuns()
	for _, weapon in pairs(Game_Workspace.DroppedGuns) do
		weapon:Destroy()
	end
end

Evt.Slide.OnServerEvent:Connect(function(plr)
	if plr.Character and plr.Character:FindFirstChild("UpperTorso") and plr.Character.UpperTorso:FindFirstChild("Slide") then
		plr.Character.UpperTorso.Slide:Play()
	end
end)


plr.PlayerAdded:Connect(function(player)

	player.CharacterRemoving:Connect(function(char)

		if char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0 and gameRules.DropWeaponsOnLeave then
			local pos = char.UpperTorso.CFrame
			local tools = {}

			-- Get tools before player leaves
			for _, currTool in pairs(player.Backpack:GetChildren()) do
				if currTool:IsA("Tool") and currTool:FindFirstChild("Settings") then
					table.insert(tools,currTool)
					currTool.Parent = nil
				end
			end

			if char:FindFirstChildWhichIsA("Tool") and char:FindFirstChildWhichIsA("Tool"):FindFirstChild("Settings") then
				table.insert(tools,char:FindFirstChildWhichIsA("Tool"))
				char:FindFirstChildWhichIsA("Tool").Parent = nil
				--SpawnGun(gunName,char.UpperTorso.CFrame * CFrame.new(math.random(-5,5) / 10,1,-2),char[gunName],player)
			end

			for _, gun in pairs(tools) do
				--SpawnGun(gun.Name,pos,gun)
				wait()
			end
		end

	end)

	for i,v in ipairs(_G.TempBannedPlayers) do
		if v == player.Name then
			player:Kick('Blacklisted')
			warn(player.Name.." (Temporary Banned) tried to join to server")
			break
		end
	end

	for i,v in ipairs(gameRules.Blacklist) do
		if v == player.UserId then
			player:Kick('Blacklisted')
			warn(player.Name.." (Blacklisted) tried to join to server")
			break
		end
	end

	if gameRules.AgeRestrictEnabled and not Run:IsStudio() then
		if player.AccountAge < gameRules.AgeLimit then
			--player:Kick('Age restricted server! Please wait: '..(gameRules.AgeLimit - player.AccountAge)..' Days')
		end
	end



	if CheckHostID(player) then
		player.Chatted:Connect(function(msg)
			-- Convert to lowercase
			msg = string.lower(msg)

			local pfx = gameRules.CommandPrefix

			if msg == pfx.."Gamelog" or msg == pfx.."Game log" then
				Evt.CombatLog:FireClient(player,CombatLog)
			elseif msg == pfx.."reset all" or msg == pfx.."resetall" or msg == pfx.."reset" then
				ResetGlass()
				ResetLights()
			elseif msg == pfx.."reset glass" or msg == pfx.."resetglass" then
				ResetGlass()
			elseif msg == pfx.. "reset lights" or msg == pfx.."resetlights" then
				ResetLights()
			elseif msg == pfx.. "clear guns" or msg == pfx.."clearguns" then
				ClearDroppedGuns()
			end
		end)
	end


	local setupWorked = false
	player.CharacterAdded:Connect(function(char)
		setupWorked = true
		SetupCharacter(player,char)
	end)

	-- Character setup failsafe
	repeat wait() until player.Character
	if not setupWorked then SetupCharacter(player,player.Character) end
end)

function SetupCharacter(player, char)
	for _, part in pairs(char:GetDescendants()) do
		if part:IsA("BasePart") and part.Name ~= "BodyHitbox" and part.Name ~= "HeadHitbox"then
			part.CollisionGroup = "Characters"
		end
	end

	if gameRules.TeamTags then
		local L_17_ = HUDs:WaitForChild('TeamTagUI'):Clone()
		L_17_.Parent = char
		L_17_.Adornee = char.Head
	end

	char.Humanoid.BreakJointsOnDeath = false
	char.Humanoid.Died:Connect(function()
		PlayCharacterSound(char,"Died")
		pcall(function()
			Ragdoll(char, false)
		end)

		-- Start knocked system instead of immediate death
		local Client = char:FindFirstChild("Client")
		if Client then
			if not Client:GetAttribute("Jet") and RS.MapStatus.Value == "InGame" or RS.MapStatus.Value == "Ready" then
				Client:SetAttribute("Knocked", true)
				Client:SetAttribute("BleedoutTime", 30)
				Client:SetAttribute("BeingRevived", false)
				Client:SetAttribute("ReviveProgress", 0)
				Client:SetAttribute("BleedingFaster", false) -- New attribute

				-- Notify all team members
				for _, teamPlayer in pairs(game.Players:GetPlayers()) do
					if teamPlayer.Team == player.Team and teamPlayer ~= player then
						Evt.TeammateDowned:FireClient(teamPlayer, player)
					end
				end

				-- Start bleedout countdown with variable speed
				task.spawn(function()
					while Client:GetAttribute("Knocked") and Client:GetAttribute("BleedoutTime") > 0 do
						local bleedRate = Client:GetAttribute("BleedingFaster") and 0.01 or 0.1 -- Bleed 2x faster when holding E
						task.wait(bleedRate)

						if Client:GetAttribute("Knocked") then
							local newTime = Client:GetAttribute("BleedoutTime") - 0.1
							Client:SetAttribute("BleedoutTime", newTime)

							if newTime <= 0 then
								-- Actually kill the player
								ActuallyKillPlayer(player, char)
								break
							end
						end
					end
				end)
			else
				print("FullyKilling")
				ActuallyKillPlayer(player, char)
			end
		end
	end)

	repeat wait() until player:FindFirstChild("Backpack")

	-- Check the player's backpack for guns
	for _, tool in pairs(player.Backpack:GetChildren()) do
		if tool:FindFirstChild("Settings") and require(tool.Settings).Holster then
			CheckHolster(player,tool.Name,require(tool.Settings),tool)
		end
	end

	-- Set up listeners for future tools
	player.Backpack.ChildAdded:Connect(function(newChild)
		if newChild:IsA("Tool") and newChild:FindFirstChild("Settings") and require(newChild.Settings).Holster then
			CheckHolster(player,newChild.Name,require(newChild.Settings),newChild)
		end
	end)

	player.Backpack.ChildRemoved:Connect(function(newChild)
		if newChild:IsA("Tool") and newChild:FindFirstChild("Settings") and char:FindFirstChild("S_"..newChild.Name) and not player.Backpack:FindFirstChild(newChild.Name) then
			char:FindFirstChild("S_"..newChild.Name):Destroy()
		end
	end)
end

function ActuallyKillPlayer(player, char)
	local Client = char:FindFirstChild("Client")
	if Client then
		Client:SetAttribute("Knocked", false)
	end

	-- Notify team members
	for _, teamPlayer in pairs(game.Players:GetPlayers()) do
		if teamPlayer.Team == player.Team and teamPlayer ~= player then
			Evt.TeammateDied:FireClient(teamPlayer, player)
		end
	end

	-- Drop weapons logic (existing code)
	if gameRules.DropWeaponsOnDeath then
		for _, currTool in pairs(player.Backpack:GetChildren()) do
			if currTool:IsA("Tool") and currTool:FindFirstChild("Settings") then
				local gunFrame
				if char:FindFirstChild("S_"..currTool.Name) then
					gunFrame = char["S_"..currTool.Name].Handle.CFrame
					char:FindFirstChild("S_"..currTool.Name):Destroy()
				else
					gunFrame = char.UpperTorso.CFrame * CFrame.new(math.random(-5,5) / 10,1,-2)
				end

				local Settings = require(currTool:WaitForChild("Settings"))
				if Settings.Type == "Gun" or Settings.Type == "Bomb" then
					--SpawnGun(currTool.Name, gunFrame, currTool, player, Settings)
				end
				wait()
			end
		end

		wait()
		if char:FindFirstChildWhichIsA("Tool") and char:FindFirstChildWhichIsA("Tool"):FindFirstChild("Settings") then
			local gunName = char:FindFirstChildWhichIsA("Tool").Name
			local Settings = require(char:FindFirstChildWhichIsA("Tool"):WaitForChild("Settings"))
			--SpawnGun(gunName,char.UpperTorso.CFrame * CFrame.new(math.random(-5,5) / 10,1,-2),char[gunName],player,Settings)
		end
	end

	UpdateLog(player, char.Humanoid)
	
	player.PlayerData.Spawned.Value = false

	-- Reset stats
	--player.PlayerData.Streak.Value = 0

	-- Wait before respawning
	task.wait(5)
	if player.Character == char then
		player:LoadCharacter()
	end
end

Evt.ReviveTeammate.OnServerEvent:Connect(function(Player, Victim, UsingStim)
	if Player and Player.Character and Player.Character.Humanoid.Health > 0 then
		local P1_Client = Player.Character:FindFirstChild("Client")

		if P1_Client == nil or P1_Client:GetAttribute("Collapsed") then
			return
		end

		if Victim and Victim.Character then
			if Player.Character and Victim.Character and 
				(Player.Character.UpperTorso.Position - Victim.Character.UpperTorso.Position).Magnitude <= 15 then

				local P2_Client = Victim.Character:FindFirstChild("Client")

				if P2_Client == nil or not P2_Client:GetAttribute("Knocked") then
					return
				end

				-- Check if using stim
				local reviveTime = 2
				


				P2_Client:SetAttribute("BeingRevived", true)
				P2_Client:SetAttribute("ReviveProgress", 0)

				-- Start revive process
				local reviveStartTime = tick()
				local cancelled = false

				-- Monitor for cancellation
				local connection
				connection = P1_Client:GetAttributeChangedSignal("Collapsed"):Connect(function()
					if P1_Client:GetAttribute("Collapsed") then
						cancelled = true
						P2_Client:SetAttribute("BeingRevived", false)
						P2_Client:SetAttribute("ReviveProgress", 0)
						connection:Disconnect()
					end
				end)

				-- Check distance every frame
				while not cancelled and tick() - reviveStartTime < reviveTime do
					task.wait(0.1)

					-- Check if still in range
					if not Player.Character or not Victim.Character or
						(Player.Character.UpperTorso.Position - Victim.Character.UpperTorso.Position).Magnitude > 15 then
						cancelled = true
						break
					end

					-- Check if victim is still knocked
					if not P2_Client:GetAttribute("Knocked") then
						cancelled = true
						break
					end

					-- Update progress
					local progress = (tick() - reviveStartTime) / reviveTime
					P2_Client:SetAttribute("ReviveProgress", math.min(progress, 1))
				end

				connection:Disconnect()

				if not cancelled then
					-- Successfully revived
					P2_Client:SetAttribute("Knocked", false)
					P2_Client:SetAttribute("BeingRevived", false)
					P2_Client:SetAttribute("ReviveProgress", 0)

					-- Restore some health
					if Victim.Character.Humanoid then
						Victim.Character.Humanoid.Health = Victim.Character.Humanoid.MaxHealth * 0.5
					end
					
					local RespawnPos = Victim.Character.UpperTorso.CFrame

					-- Notify clients
					Evt.PlayerRevived:FireClient(Victim)

					-- Notify team members
					for _, teamPlayer in pairs(game.Players:GetPlayers()) do
						if teamPlayer.Team == Player.Team then
							Evt.TeammateRevived:FireClient(teamPlayer, Victim)
						end
					end
					
					Victim:LoadCharacter()
					
					Victim.Character:SetPrimaryPartCFrame(RespawnPos)
				else
					-- Revive cancelled
					P2_Client:SetAttribute("BeingRevived", false)
					P2_Client:SetAttribute("ReviveProgress", 0)
				end
			end
		end
	end
end)

BleedOutFasterEvent.OnServerEvent:Connect(function(player, isFaster)
	if player.Character and player.Character:FindFirstChild("Client") then
		local Client = player.Character.Client
		if Client:GetAttribute("Knocked") then
			Client:SetAttribute("BleedingFaster", isFaster)
		end
	end
end)

-- Check if a holster model can be added
function CheckHolster(player,weaponName,toolSettings,tool)
	if player.Character and not player.Character:FindFirstChild("S_"..weaponName) and not player.Character:FindFirstChild(weaponName) then
		HolsterWeapon(player,weaponName,toolSettings,tool)
	end
end

-- Weld holster model to the player
function HolsterWeapon(player,weaponName,toolSettings,tool)
	if player.Character:FindFirstChild(toolSettings.HolsterPoint) then
		local holsterPoint = toolSettings.HolsterPoint
		local holsterModel = GunModels:FindFirstChild(weaponName):Clone()
		holsterModel.Name = "S_"..weaponName
		holsterModel.Parent = player.Character
		loadAttachment(holsterModel,toolSettings,tool,player)

		if holsterModel:FindFirstChild("Nodes") then
			holsterModel.Nodes:Destroy()
		end

		local config = tool:FindFirstChild("RepValues")

		for _, part in pairs(holsterModel:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "Handle" then
				if part.Name == "SightMark" or part.Name == "SightMark2" or (part.Name == "Warhead" and config and config.Mag.Value < 1) then
					part:Destroy()
				else
					local newWeld = Ultil.WeldComplex(holsterModel.Handle,part,part.Name)
					newWeld.Parent = holsterModel.Handle
					part.Anchored = false
					part.CanCollide = false
				end
			end
		end

		local holsterWeld = Ultil.Weld(player.Character[holsterPoint],holsterModel.Handle,toolSettings.HolsterCFrame)
		holsterWeld.Parent = holsterModel
		holsterWeld.Name = "HolsterWeld"
		holsterModel.Handle.Anchored = false
	end
end

function SpawnGun(gunName,gunPosition,tool,player,config)
	local dropModel = GunModels:FindFirstChild(gunName):Clone()
	dropModel.Handle.Anchored = false
	dropModel.Handle.CanTouch = true
	loadAttachment(dropModel,config,tool,player)
	--dropModel.Handle.CFrame = CFrame.new(dropModel["Origin Position"])

	dropModel.PrimaryPart = dropModel.Handle
	dropModel.Handle.Size = dropModel:GetExtentsSize()

	if dropModel:FindFirstChild("Nodes") then 
		dropModel.Nodes:Destroy()
	end

	if #dropModel:GetChildren() < 2 then
		dropModel.Handle.CanCollide = true
	else
		dropModel.Handle.CanCollide = false
	end
	
	

	for _, part in pairs(dropModel:GetDescendants()) do
		if part.Name == "Warhead" and config and config.IsLauncher and tool:FindFirstChild("RepValues") and tool.RepValues.Mag.Value < 1 then
			part:Destroy()
		elseif part:IsA("BasePart") and part.Name ~= "Handle" then
			local newWeld = Ultil.WeldComplex(dropModel.Handle,part,part.Name)
			newWeld.Parent = dropModel.Handle
			part.Anchored = false
			part.CanCollide = true
			part.CanTouch = false
			part.CollisionGroup = "Guns"
		end
	end

	if tool then
		tool.Parent = dropModel
	else
		tool = Engine.ToolStorage:FindFirstChild(gunName):Clone()
	end
	
	tool:SetAttribute("IsLoadout",false)
	
	local Config2 = require(tool:WaitForChild("Settings"))
	
	if config then
		Config2.SightAtt = config.SightAtt
		Config2.BarrelAtt = config.BarrelAtt
		Config2.UnderBarrelAtt = config.UnderBarrelAtt
		Config2.OtherAtt = config.OtherAtt
		Config2.AmmoAtt = config.AmmoAtt
		tool:SetAttribute("SightAtt",config.SightAtt)
		tool:SetAttribute("BarrelAtt",config.BarrelAtt)
		tool:SetAttribute("UnderBarrelAtt",config.UnderBarrelAtt)
		tool:SetAttribute("OtherAtt",config.OtherAtt)
		tool:SetAttribute("AmmoAtt",config.AmmoAtt)
	end

	local clickDetector = Instance.new("ProximityPrompt")
	clickDetector.RequiresLineOfSight = false
	clickDetector.ActionText = "Pick Up"
	clickDetector.ObjectText = gunName
	clickDetector.KeyboardKeyCode = Enum.KeyCode.E
	clickDetector.GamepadKeyCode = Enum.KeyCode.ButtonX
	clickDetector.MaxActivationDistance = gameRules.PickupDistance
	clickDetector.Parent = dropModel
	clickDetector.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
	clickDetector.Triggered:Connect(function(player)
		local EquippedTool = player.Character:FindFirstChildWhichIsA("Tool")
		if EquippedTool then

			local NewToolSettings = require(tool:WaitForChild("Settings"))
			if not player.Backpack:FindFirstChild(tool.Name) then
				--if player.Character:FindFirstChild(tool.Name) then
				--	if player.Character[tool.Name]:IsA("Tool") then
				--		return
				--	end
				--end
				tool.Parent = player.Backpack
				if NewToolSettings.Type == "Gun" then
					local Tool = player.Character:FindFirstChildWhichIsA("Tool")
					local Pos = player.Character.UpperTorso.CFrame * CFrame.new(math.random(-5,5) / 10,1,-2)
					SpawnGun(Tool.Name,Pos,Tool)
					player.Character.Humanoid:EquipTool(tool)
					--player.PlayerData.Secondary.Value = tool.Name
				end

				--Evt.EquipGun:Fire
				dropModel:Destroy()
				local NewSound = Engine.FX.WeaponPickup:Clone()
				NewSound.Parent = player.Character.UpperTorso
				--NewSound.PlaybackSpeed = math.random(30,50)/40
				NewSound:Play()
				NewSound.PlayOnRemove = true
				NewSound:Destroy()
			end
		end
	end)	

	local OutLine = Engine.FX.Highlight:Clone()

	OutLine.Parent = dropModel

	dropModel.Parent = Game_Workspace.DroppedGuns

	dropModel.Handle.Touched:Connect(function()
		if dropModel.Handle.AssemblyLinearVelocity.Magnitude > 7 then
			local DropSounds = Engine.FX.GunDrop
			local NewSound = DropSounds["GunDrop"..math.random(#DropSounds:GetChildren())]:Clone()
			NewSound.Parent = dropModel.Handle
			NewSound.PlaybackSpeed = math.random(30,50)/40
			NewSound:Play()
			NewSound.PlayOnRemove = true
			NewSound:Destroy()
		end
	end)

	if player then dropModel.Handle:SetNetworkOwner(player) end

	dropModel:SetPrimaryPartCFrame(gunPosition)

	if #Game_Workspace.DroppedGuns:GetChildren() > gameRules.MaxDroppedWeapons then
		Game_Workspace.DroppedGuns:GetChildren()[1]:Destroy()
	end

	if gameRules.TimeDespawn then
		Debris:AddItem(dropModel,gameRules.WeaponDespawnTime)
	end

	return dropModel
end

Evt.Shell.OnServerEvent:Connect(function(Player,Shell,Origin)
	Evt.Shell:FireAllClients(Shell,Origin)
end)

Evt.DropWeapon.OnServerEvent:Connect(function(player,tool,toolConfig)
	local tool = player.Backpack:FindFirstChild(tool.Name)
	--print(player.Name.. " dropped a " ..tool.Name)
	--tool:Destroy()
	local NewSound = Engine.FX.WeaponDrop:Clone()
	NewSound.Parent = player.Character.UpperTorso
	--NewSound.PlaybackSpeed = math.random(30,50)/40
	NewSound:Play()
	NewSound.PlayOnRemove = true
	NewSound:Destroy()
	--SpawnGun(tool.Name,player.Character.UpperTorso.CFrame * CFrame.new(0,1,-3),tool,player,toolConfig)
end)

Evt.DropAmmo.OnServerEvent:Connect(function(Player,tool,action)
	if action == "Weld" then
		local canModel = Engine.AmmoModels.AmmoBox:Clone()
		local handle = tool.Handle
		for _, part in pairs(canModel:GetChildren()) do
			if part:IsA("BasePart") and part.Name ~= "Main" then
				local newWeld = Ultil.WeldComplex(canModel.Main,part,part.Name)
				newWeld.Parent = canModel.Main
				part.Anchored = false
				part.CanCollide = true
				part.CanTouch = false
			end

			part.CollisionGroup = "Guns"

			if part.Name == "Main" then
				for _, child in pairs(part:GetChildren()) do
					if child:FindFirstChildWhichIsA("TextLabel") then
						child:FindFirstChildWhichIsA("TextLabel").Text = tool.AmmoType.Value
					end
				end
			end
		end
		local newWeld = Ultil.Weld(handle,canModel.Main,CFrame.new(0,-0.2,0),CFrame.new())
		newWeld.Name = "ToolWeld"
		newWeld.Parent = handle
		canModel.Main.Anchored = false
		handle.Anchored = false
		canModel.Parent = tool
	elseif action == "Destroy" then
		if tool:FindFirstChildWhichIsA("Model") then
			tool:FindFirstChildWhichIsA("Model"):Destroy()
			tool.Handle.ToolWeld:Destroy()
		end
	elseif action == "Drop" then
		local canModel = tool:FindFirstChildWhichIsA("Model")
		local handle = tool.Handle
		handle.ToolWeld:Destroy()
		canModel.Parent = Game_Workspace.DroppedGuns
		canModel.Main.Touched:Connect(function(hitPart)
			if plr:GetPlayerFromCharacter(hitPart.Parent) then

				local player = plr:GetPlayerFromCharacter(hitPart.Parent)
				local f = player.Backpack:GetChildren()
				for i = 1, #f do

					if f[i]:IsA("Tool") and f[i]:FindFirstChild("Settings") then
						if tool.AmmoType.Value == "Universal" then
							Evt.Refil:FireClient(player, f[i], tool.Inf.Value, tool.Stored)
							if not canModel.Main.Sound.Playing then
								canModel.Main.Sound:Play()
							end
						elseif require(f[i].Settings).BulletType == tool.AmmoType.Value then
							Evt.Refil:FireClient(player, f[i], tool.Inf.Value, tool.Stored)
							if not canModel.Main.Sound.Playing then
								canModel.Main.Sound:Play()
							end
						end
					end
				end

				-- No more ammo
				if tool.Stored.Value <= 0 and not tool.Inf.Value then
					canModel:Destroy()
					tool:Destroy()
					return
				end
			end
		end)
		tool.Parent = nil

		local Proxim = Instance.new("ProximityPrompt",canModel)
		Proxim.MaxActivationDistance = gameRules.PickupDistance
		Proxim.Triggered:Connect(function(Player)
			--print("Give")
			if Player.Character and Player.Character:FindFirstChild("Humanoid") ~= nil and Player.Character.Humanoid.Health > 0 then
				Player.Character.Humanoid:UnequipTools()
			end
			tool.Parent = Player:WaitForChild("Backpack")
			canModel:Destroy()
		end)

		Debris:AddItem(canModel, gameRules.AmmoBoxDespawn)
	end
end)


for _, spawner in pairs(Game_Workspace.WeaponSpawners:GetChildren()) do
	local constrainedValue = Instance.new("DoubleConstrainedValue")
	local maxTime = spawner.Config.WaitTime

	constrainedValue.Name = "WaitTime"
	constrainedValue.MaxValue = maxTime.Value
	constrainedValue.Value = maxTime.Value
	constrainedValue.Parent = spawner.Config

	maxTime:Destroy()
end

-- Footsteps
--local stepEvent = Evt.Step
--stepEvent.OnServerEvent:Connect(function(player,soundId,volume,timeStamp)
--	stepEvent:FireAllClients(player,soundId,volume,timeStamp)
--end)

-- Blood effects
--if gameRules.BloodSplats then
--	Mods["Realistic Blood"].Parent = game:GetService("ServerScriptService")
--end

-- Weapon spawning
function SetupSpawner(spawner)
	spawner.Transparency = 1
	spawner.Size = Vector3.new(0.2,0.2,0.2)
	spawner.CanCollide = false

	local evt = Instance.new("BindableEvent")
	evt.Name = "SpawnEvent"
	evt.Parent = spawner

	evt.Event:Connect(function()
		local newGun = SpawnGun(string.sub(spawner.Name,7),spawner.CFrame)
		newGun.Parent = spawner
	end)

	Mods.WeaponSpawn:Clone().Parent = spawner
end

for _, spawner in pairs(Game_Workspace.WeaponSpawners:GetChildren()) do
	SetupSpawner(spawner)
end

Game_Workspace.WeaponSpawners.ChildAdded:Connect(function(newChild)
	SetupSpawner(newChild)
end)

-- Print version

--while wait(1) do
--	for _, spawner in pairs(Game_Workspace.WeaponSpawners:GetChildren()) do
--		spawner.Transparency = 1
--		spawner.Size = Vector3.new(0.2,0.2,0.2)
--		spawner.CanCollide = false

--		if not gameRules.SpawnStacking and not spawner:FindFirstChild("CurrentGun") then
--			local objValue = Instance.new("ObjectValue")
--			objValue.Name = "CurrentGun"
--			objValue.Parent = spawner
--		end

--		if not gameRules.SpawnStacking then
--			if not spawner.CurrentGun.Value then
--				spawner.Config.WaitTime.Value = spawner.Config.WaitTime.Value - 1
--			end
--		else
--			spawner.Config.WaitTime.Value = spawner.Config.WaitTime.Value - 1
--		end

--		if spawner.Config.WaitTime.Value < 1 then
--			if spawner.Config.SpawnNumber.Value > 0 or spawner.Config.Infinite.Value then
--				spawner.Config.SpawnNumber.Value = spawner.Config.SpawnNumber.Value - 1
--				local newGun = SpawnGun(string.sub(spawner.Name,7),spawner.CFrame)
--				spawner.Config.WaitTime.Value = spawner.Config.WaitTime.MaxValue

--				if not gameRules.SpawnStacking then
--					spawner.CurrentGun.Value = newGun

--					newGun.Changed:Connect(function()
--						if not newGun.Parent then
--							spawner.CurrentGun.Value = nil
--						end
--					end)
--				end
--			else
--				spawner:Destroy()
--			end
--		end
--	end
--end

Evt.ThrowSupplyBox.OnServerEvent:Connect(function(Player, Tool, Origin, Direction)
	if not Player or not Player.Character or Player.Character.Humanoid.Health <= 0 then
		return
	end

	local Settings = require(Tool:WaitForChild("Settings"))

	-- Create the supply box
	local SupplyBox = Engine.GunModels:FindFirstChild("Supply Box"):Clone()
	SupplyBox.Name = Player.Name .. "'s Supply Box"

	-- Setup physics
	SupplyBox.PrimaryPart = SupplyBox:FindFirstChild("Handle")
	SupplyBox.Handle.Anchored = false
	SupplyBox.Handle.CanCollide = true
	for i,v in pairs(SupplyBox:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "Handle" then
			Ultil.WeldComplex(v,SupplyBox.Handle,v.Name)
		end
	end
	
	SupplyBox.Parent = Game_Workspace.Server
	
	SupplyBox:PivotTo(Player.Character.UpperTorso.CFrame * CFrame.new(math.random(-5,5) / 10,1,-2))


	-- Apply throw force
	--local throwForce = Direction * 50 * SupplyBox.Handle:GetMass()
	--SupplyBox.Handle:ApplyImpulse(throwForce)

	-- Store ammo data
	local AmmoData = Instance.new("Folder", SupplyBox)
	AmmoData.Name = "AmmoData"

	local HeavyAmmo = Instance.new("IntValue", AmmoData)
	HeavyAmmo.Name = "Heavy"
	HeavyAmmo.Value = Settings.Heavy

	local MediumAmmo = Instance.new("IntValue", AmmoData)
	MediumAmmo.Name = "Medium"
	MediumAmmo.Value = Settings.Medium

	local LightAmmo = Instance.new("IntValue", AmmoData)
	LightAmmo.Name = "Light"
	LightAmmo.Value = Settings.Light

	local RocketAmmo = Instance.new("IntValue", AmmoData)
	RocketAmmo.Name = "Rocket"
	RocketAmmo.Value = Settings.Rocket

	local ShotgunAmmo = Instance.new("IntValue", AmmoData)
	ShotgunAmmo.Name = "Shotgun"
	ShotgunAmmo.Value = Settings.Shotgun

	local GrenadeAmmo = Instance.new("IntValue", AmmoData)
	GrenadeAmmo.Name = "Grenade"
	GrenadeAmmo.Value = Settings.Grenade

	-- Store team info
	local TeamValue = Instance.new("StringValue", SupplyBox)
	TeamValue.Name = "Team"
	TeamValue.Value = Player.Team.Name

	-- Create proximity prompt
	local ProximityPrompt = Instance.new("ProximityPrompt", SupplyBox.Handle)
	ProximityPrompt.ActionText = "Resupply"
	ProximityPrompt.ObjectText = "Supply Box"
	ProximityPrompt.KeyboardKeyCode = Enum.KeyCode.E
	ProximityPrompt.GamepadKeyCode = Enum.KeyCode.ButtonX
	ProximityPrompt.HoldDuration = 1
	ProximityPrompt.MaxActivationDistance = 10
	ProximityPrompt.RequiresLineOfSight = false

	ProximityPrompt.Triggered:Connect(function(TriggerPlayer)
		if TriggerPlayer.Team.Name ~= TeamValue.Value then
			return -- Only same team can use
		end

		if not TriggerPlayer.Character or TriggerPlayer.Character.Humanoid.Health <= 0 then
			return
		end

		local resupplied = false

		-- Resupply weapons
		for _, tool in pairs(TriggerPlayer.Backpack:GetChildren()) do
			
			if tool:IsA("Tool") and tool:FindFirstChild("Settings") then
				local toolSettings = require(tool.Settings)

				if toolSettings.Type == "Gun" and toolSettings.WeaponType then
					local ammoType = toolSettings.AmmoType
					local ammoValue
					
					if AmmoData[ammoType] then
						ammoValue = AmmoData[ammoType]
					end

					if ammoValue and ammoValue.Value > 0 then
						local ammoNeeded = toolSettings.MaxStoredAmmo - toolSettings.StoredAmmo
						local ammoToGive = math.min(ammoNeeded, ammoValue.Value)

						if ammoToGive > 0 then
							Evt.Refil:FireClient(TriggerPlayer, tool, false, ammoValue)
							ammoValue.Value = ammoValue.Value - math.ceil(ammoToGive / toolSettings.Ammo)
							resupplied = true
						end
					end
				end
			end
		end
		
		if TriggerPlayer.Character and TriggerPlayer.Character:FindFirstChildWhichIsA("Tool") then
			local tool = TriggerPlayer.Character:FindFirstChildWhichIsA("Tool")
			if tool:IsA("Tool") and tool:FindFirstChild("Settings") then
				local toolSettings = require(tool.Settings)

				if toolSettings.Type == "Gun" and toolSettings.WeaponType then
					local ammoType = toolSettings.AmmoType
					local ammoValue

					if AmmoData[ammoType] then
						ammoValue = AmmoData[ammoType]
					end

					if ammoValue and ammoValue.Value > 0 then
						local ammoNeeded = toolSettings.MaxStoredAmmo - toolSettings.StoredAmmo
						local ammoToGive = math.min(ammoNeeded, ammoValue.Value)

						if ammoToGive > 0 then
							Evt.Refil:FireClient(TriggerPlayer, tool, false, ammoValue)
							ammoValue.Value = ammoValue.Value - math.ceil(ammoToGive / toolSettings.Ammo)
							resupplied = true
						end
					end
				end
			end
		end

		-- Resupply grenades
		if TriggerPlayer.Character:FindFirstChild("Client") then
			local Client = TriggerPlayer.Character.Client
			if AmmoData.Grenade.Value > 0 then
				local maxGrenades = 2
				local currentGrenades = 0 -- You'll need to track this in your system

				if currentGrenades < maxGrenades then
					local grenadesNeeded = maxGrenades - currentGrenades
					local grenadesGiven = math.min(grenadesNeeded, AmmoData.Grenade.Value)
					AmmoData.Grenade.Value = AmmoData.Grenade.Value - grenadesGiven
					-- Add grenades to player (implement based on your grenade system)
					resupplied = true
				end
			end
		end

		if resupplied then
			-- Play resupply sound
			local ResupplySound = Engine.FX:FindFirstChild("Resupply")
			if ResupplySound then
				local sound = ResupplySound:Clone()
				sound.Parent = SupplyBox.Handle
				sound:Play()
				sound.Ended:Connect(function()
					sound:Destroy()
				end)
			end
		end

		-- Check if box is empty
		local totalAmmo = AmmoData.Heavy.Value + AmmoData.Medium.Value + 
			AmmoData.Light.Value + AmmoData.Rocket.Value + 
			AmmoData.Shotgun.Value + AmmoData.Grenade.Value

		if totalAmmo <= 0 then
			SupplyBox:Destroy()
		end
	end)

	-- Add highlight for visibility
	local Highlight = Instance.new("Highlight", SupplyBox)
	Highlight.FillColor = Player.TeamColor.Color
	Highlight.OutlineColor = Player.TeamColor.Color
	Highlight.FillTransparency = 0.5
	Highlight.OutlineTransparency = 0

	-- Despawn after time
	game:GetService("Debris"):AddItem(SupplyBox, 120) -- 2 minutes
end)
